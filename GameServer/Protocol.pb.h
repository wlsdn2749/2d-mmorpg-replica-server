// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Protocol.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Protocol_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Protocol_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Protocol_2eproto;
namespace Protocol {
class C_ChangeRoomReady;
struct C_ChangeRoomReadyDefaultTypeInternal;
extern C_ChangeRoomReadyDefaultTypeInternal _C_ChangeRoomReady_default_instance_;
class C_CharacterListRequest;
struct C_CharacterListRequestDefaultTypeInternal;
extern C_CharacterListRequestDefaultTypeInternal _C_CharacterListRequest_default_instance_;
class C_CreateCharacterRequest;
struct C_CreateCharacterRequestDefaultTypeInternal;
extern C_CreateCharacterRequestDefaultTypeInternal _C_CreateCharacterRequest_default_instance_;
class C_EnterGame;
struct C_EnterGameDefaultTypeInternal;
extern C_EnterGameDefaultTypeInternal _C_EnterGame_default_instance_;
class C_JwtLoginRequest;
struct C_JwtLoginRequestDefaultTypeInternal;
extern C_JwtLoginRequestDefaultTypeInternal _C_JwtLoginRequest_default_instance_;
class C_LeaveGame;
struct C_LeaveGameDefaultTypeInternal;
extern C_LeaveGameDefaultTypeInternal _C_LeaveGame_default_instance_;
class C_PlayerMoveRequest;
struct C_PlayerMoveRequestDefaultTypeInternal;
extern C_PlayerMoveRequestDefaultTypeInternal _C_PlayerMoveRequest_default_instance_;
class CharacterSummaryInfo;
struct CharacterSummaryInfoDefaultTypeInternal;
extern CharacterSummaryInfoDefaultTypeInternal _CharacterSummaryInfo_default_instance_;
class PlayerInfo;
struct PlayerInfoDefaultTypeInternal;
extern PlayerInfoDefaultTypeInternal _PlayerInfo_default_instance_;
class PlayerMoveInfo;
struct PlayerMoveInfoDefaultTypeInternal;
extern PlayerMoveInfoDefaultTypeInternal _PlayerMoveInfo_default_instance_;
class S_BroadcastMonsterAttack;
struct S_BroadcastMonsterAttackDefaultTypeInternal;
extern S_BroadcastMonsterAttackDefaultTypeInternal _S_BroadcastMonsterAttack_default_instance_;
class S_BroadcastMonsterDeath;
struct S_BroadcastMonsterDeathDefaultTypeInternal;
extern S_BroadcastMonsterDeathDefaultTypeInternal _S_BroadcastMonsterDeath_default_instance_;
class S_BroadcastMonsterMove;
struct S_BroadcastMonsterMoveDefaultTypeInternal;
extern S_BroadcastMonsterMoveDefaultTypeInternal _S_BroadcastMonsterMove_default_instance_;
class S_BroadcastPlayerEnter;
struct S_BroadcastPlayerEnterDefaultTypeInternal;
extern S_BroadcastPlayerEnterDefaultTypeInternal _S_BroadcastPlayerEnter_default_instance_;
class S_BroadcastPlayerLeave;
struct S_BroadcastPlayerLeaveDefaultTypeInternal;
extern S_BroadcastPlayerLeaveDefaultTypeInternal _S_BroadcastPlayerLeave_default_instance_;
class S_BroadcastPlayerMove;
struct S_BroadcastPlayerMoveDefaultTypeInternal;
extern S_BroadcastPlayerMoveDefaultTypeInternal _S_BroadcastPlayerMove_default_instance_;
class S_ChangeRoomBegin;
struct S_ChangeRoomBeginDefaultTypeInternal;
extern S_ChangeRoomBeginDefaultTypeInternal _S_ChangeRoomBegin_default_instance_;
class S_ChangeRoomCommit;
struct S_ChangeRoomCommitDefaultTypeInternal;
extern S_ChangeRoomCommitDefaultTypeInternal _S_ChangeRoomCommit_default_instance_;
class S_CharacterListReply;
struct S_CharacterListReplyDefaultTypeInternal;
extern S_CharacterListReplyDefaultTypeInternal _S_CharacterListReply_default_instance_;
class S_CreateCharacterReply;
struct S_CreateCharacterReplyDefaultTypeInternal;
extern S_CreateCharacterReplyDefaultTypeInternal _S_CreateCharacterReply_default_instance_;
class S_DespawnMonster;
struct S_DespawnMonsterDefaultTypeInternal;
extern S_DespawnMonsterDefaultTypeInternal _S_DespawnMonster_default_instance_;
class S_EnterGame;
struct S_EnterGameDefaultTypeInternal;
extern S_EnterGameDefaultTypeInternal _S_EnterGame_default_instance_;
class S_JwtLoginReply;
struct S_JwtLoginReplyDefaultTypeInternal;
extern S_JwtLoginReplyDefaultTypeInternal _S_JwtLoginReply_default_instance_;
class S_LeaveGame;
struct S_LeaveGameDefaultTypeInternal;
extern S_LeaveGameDefaultTypeInternal _S_LeaveGame_default_instance_;
class S_PlayerList;
struct S_PlayerListDefaultTypeInternal;
extern S_PlayerListDefaultTypeInternal _S_PlayerList_default_instance_;
class S_PlayerMoveReply;
struct S_PlayerMoveReplyDefaultTypeInternal;
extern S_PlayerMoveReplyDefaultTypeInternal _S_PlayerMoveReply_default_instance_;
class S_SpawnMonster;
struct S_SpawnMonsterDefaultTypeInternal;
extern S_SpawnMonsterDefaultTypeInternal _S_SpawnMonster_default_instance_;
class Vector2Info;
struct Vector2InfoDefaultTypeInternal;
extern Vector2InfoDefaultTypeInternal _Vector2Info_default_instance_;
}  // namespace Protocol
PROTOBUF_NAMESPACE_OPEN
template<> ::Protocol::C_ChangeRoomReady* Arena::CreateMaybeMessage<::Protocol::C_ChangeRoomReady>(Arena*);
template<> ::Protocol::C_CharacterListRequest* Arena::CreateMaybeMessage<::Protocol::C_CharacterListRequest>(Arena*);
template<> ::Protocol::C_CreateCharacterRequest* Arena::CreateMaybeMessage<::Protocol::C_CreateCharacterRequest>(Arena*);
template<> ::Protocol::C_EnterGame* Arena::CreateMaybeMessage<::Protocol::C_EnterGame>(Arena*);
template<> ::Protocol::C_JwtLoginRequest* Arena::CreateMaybeMessage<::Protocol::C_JwtLoginRequest>(Arena*);
template<> ::Protocol::C_LeaveGame* Arena::CreateMaybeMessage<::Protocol::C_LeaveGame>(Arena*);
template<> ::Protocol::C_PlayerMoveRequest* Arena::CreateMaybeMessage<::Protocol::C_PlayerMoveRequest>(Arena*);
template<> ::Protocol::CharacterSummaryInfo* Arena::CreateMaybeMessage<::Protocol::CharacterSummaryInfo>(Arena*);
template<> ::Protocol::PlayerInfo* Arena::CreateMaybeMessage<::Protocol::PlayerInfo>(Arena*);
template<> ::Protocol::PlayerMoveInfo* Arena::CreateMaybeMessage<::Protocol::PlayerMoveInfo>(Arena*);
template<> ::Protocol::S_BroadcastMonsterAttack* Arena::CreateMaybeMessage<::Protocol::S_BroadcastMonsterAttack>(Arena*);
template<> ::Protocol::S_BroadcastMonsterDeath* Arena::CreateMaybeMessage<::Protocol::S_BroadcastMonsterDeath>(Arena*);
template<> ::Protocol::S_BroadcastMonsterMove* Arena::CreateMaybeMessage<::Protocol::S_BroadcastMonsterMove>(Arena*);
template<> ::Protocol::S_BroadcastPlayerEnter* Arena::CreateMaybeMessage<::Protocol::S_BroadcastPlayerEnter>(Arena*);
template<> ::Protocol::S_BroadcastPlayerLeave* Arena::CreateMaybeMessage<::Protocol::S_BroadcastPlayerLeave>(Arena*);
template<> ::Protocol::S_BroadcastPlayerMove* Arena::CreateMaybeMessage<::Protocol::S_BroadcastPlayerMove>(Arena*);
template<> ::Protocol::S_ChangeRoomBegin* Arena::CreateMaybeMessage<::Protocol::S_ChangeRoomBegin>(Arena*);
template<> ::Protocol::S_ChangeRoomCommit* Arena::CreateMaybeMessage<::Protocol::S_ChangeRoomCommit>(Arena*);
template<> ::Protocol::S_CharacterListReply* Arena::CreateMaybeMessage<::Protocol::S_CharacterListReply>(Arena*);
template<> ::Protocol::S_CreateCharacterReply* Arena::CreateMaybeMessage<::Protocol::S_CreateCharacterReply>(Arena*);
template<> ::Protocol::S_DespawnMonster* Arena::CreateMaybeMessage<::Protocol::S_DespawnMonster>(Arena*);
template<> ::Protocol::S_EnterGame* Arena::CreateMaybeMessage<::Protocol::S_EnterGame>(Arena*);
template<> ::Protocol::S_JwtLoginReply* Arena::CreateMaybeMessage<::Protocol::S_JwtLoginReply>(Arena*);
template<> ::Protocol::S_LeaveGame* Arena::CreateMaybeMessage<::Protocol::S_LeaveGame>(Arena*);
template<> ::Protocol::S_PlayerList* Arena::CreateMaybeMessage<::Protocol::S_PlayerList>(Arena*);
template<> ::Protocol::S_PlayerMoveReply* Arena::CreateMaybeMessage<::Protocol::S_PlayerMoveReply>(Arena*);
template<> ::Protocol::S_SpawnMonster* Arena::CreateMaybeMessage<::Protocol::S_SpawnMonster>(Arena*);
template<> ::Protocol::Vector2Info* Arena::CreateMaybeMessage<::Protocol::Vector2Info>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Protocol {

enum MsgId : int {
  C_JWT_LOGIN_REQUEST = 0,
  S_JWT_LOGIN_REPLY = 1,
  C_CREATE_CHARACTER_REQUEST = 2,
  S_CREATE_CHARACTER_REPLY = 3,
  C_CHARACTER_LIST_REQUEST = 4,
  S_CHARACTER_LIST_REPLY = 5,
  C_ENTER_GAME = 6,
  S_ENTER_GAME = 7,
  S_PLAYER_LIST = 8,
  S_BROADCAST_PLAYER_ENTER = 9,
  C_LEAVE_GAME = 10,
  S_LEAVE_GAME = 11,
  S_BROADCAST_PLAYER_LEAVE = 12,
  C_PLAYER_MOVE_REQUEST = 13,
  S_PLAYER_MOVE_REPLY = 14,
  S_BROADCAST_PLAYER_MOVE = 15,
  S_CHANGE_ROOM_BEGIN = 16,
  C_CHANGE_ROOM_READY = 17,
  S_CHANGE_ROOM_COMMIT = 18,
  S_SPAWN_MONSTER = 19,
  S_DESPAWN_MONSTER = 20,
  S_BROADCAST_MONSTER_MOVE = 21,
  S_BROADCAST_MONSTER_ATTACK = 22,
  S_BROADCAST_MONSTER_DEATH = 23,
  MsgId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MsgId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MsgId_IsValid(int value);
constexpr MsgId MsgId_MIN = C_JWT_LOGIN_REQUEST;
constexpr MsgId MsgId_MAX = S_BROADCAST_MONSTER_DEATH;
constexpr int MsgId_ARRAYSIZE = MsgId_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MsgId_descriptor();
template<typename T>
inline const std::string& MsgId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MsgId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MsgId_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MsgId_descriptor(), enum_t_value);
}
inline bool MsgId_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MsgId* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MsgId>(
    MsgId_descriptor(), name, value);
}
enum ELoginResult : int {
  SUCCESS = 0,
  INVALID_TOKEN = 1,
  TOKEN_EXPIRED = 2,
  SERVER_ERROR = 3,
  ELoginResult_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ELoginResult_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ELoginResult_IsValid(int value);
constexpr ELoginResult ELoginResult_MIN = SUCCESS;
constexpr ELoginResult ELoginResult_MAX = SERVER_ERROR;
constexpr int ELoginResult_ARRAYSIZE = ELoginResult_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ELoginResult_descriptor();
template<typename T>
inline const std::string& ELoginResult_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ELoginResult>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ELoginResult_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ELoginResult_descriptor(), enum_t_value);
}
inline bool ELoginResult_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ELoginResult* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ELoginResult>(
    ELoginResult_descriptor(), name, value);
}
enum EGender : int {
  GENDER_NONE = 0,
  GENDER_MALE = 1,
  GENDER_FEMALE = 2,
  EGender_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EGender_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EGender_IsValid(int value);
constexpr EGender EGender_MIN = GENDER_NONE;
constexpr EGender EGender_MAX = GENDER_FEMALE;
constexpr int EGender_ARRAYSIZE = EGender_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EGender_descriptor();
template<typename T>
inline const std::string& EGender_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EGender>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EGender_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EGender_descriptor(), enum_t_value);
}
inline bool EGender_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EGender* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EGender>(
    EGender_descriptor(), name, value);
}
enum ERegion : int {
  REGION_NONE = 0,
  REGION_GO = 1,
  REGION_BACK = 2,
  ERegion_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ERegion_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ERegion_IsValid(int value);
constexpr ERegion ERegion_MIN = REGION_NONE;
constexpr ERegion ERegion_MAX = REGION_BACK;
constexpr int ERegion_ARRAYSIZE = ERegion_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ERegion_descriptor();
template<typename T>
inline const std::string& ERegion_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ERegion>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ERegion_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ERegion_descriptor(), enum_t_value);
}
inline bool ERegion_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ERegion* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ERegion>(
    ERegion_descriptor(), name, value);
}
enum EDirection : int {
  DIR_UP = 0,
  DIR_DOWN = 1,
  DIR_LEFT = 2,
  DIR_RIGHT = 3,
  EDirection_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EDirection_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EDirection_IsValid(int value);
constexpr EDirection EDirection_MIN = DIR_UP;
constexpr EDirection EDirection_MAX = DIR_RIGHT;
constexpr int EDirection_ARRAYSIZE = EDirection_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EDirection_descriptor();
template<typename T>
inline const std::string& EDirection_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EDirection>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EDirection_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EDirection_descriptor(), enum_t_value);
}
inline bool EDirection_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EDirection* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EDirection>(
    EDirection_descriptor(), name, value);
}
enum ELeaveReason : int {
  LEAVE_UNKNOWN = 0,
  LEAVE_LOGOUT = 1,
  LEAVE_CHANGE_ROOM = 2,
  LEAVE_DISCONNECT = 3,
  ELeaveReason_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ELeaveReason_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ELeaveReason_IsValid(int value);
constexpr ELeaveReason ELeaveReason_MIN = LEAVE_UNKNOWN;
constexpr ELeaveReason ELeaveReason_MAX = LEAVE_DISCONNECT;
constexpr int ELeaveReason_ARRAYSIZE = ELeaveReason_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ELeaveReason_descriptor();
template<typename T>
inline const std::string& ELeaveReason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ELeaveReason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ELeaveReason_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ELeaveReason_descriptor(), enum_t_value);
}
inline bool ELeaveReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ELeaveReason* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ELeaveReason>(
    ELeaveReason_descriptor(), name, value);
}
enum EMoveResult : int {
  OK = 0,
  COOLDOWN = 1,
  BLOCKED = 2,
  EMoveResult_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EMoveResult_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EMoveResult_IsValid(int value);
constexpr EMoveResult EMoveResult_MIN = OK;
constexpr EMoveResult EMoveResult_MAX = BLOCKED;
constexpr int EMoveResult_ARRAYSIZE = EMoveResult_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EMoveResult_descriptor();
template<typename T>
inline const std::string& EMoveResult_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EMoveResult>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EMoveResult_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EMoveResult_descriptor(), enum_t_value);
}
inline bool EMoveResult_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EMoveResult* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EMoveResult>(
    EMoveResult_descriptor(), name, value);
}
enum EEnterReason : int {
  ENTER_UNKNOWN = 0,
  ENTER_LOGIN = 1,
  ENTER_CHANGE_ROOM = 2,
  EEnterReason_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EEnterReason_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EEnterReason_IsValid(int value);
constexpr EEnterReason EEnterReason_MIN = ENTER_UNKNOWN;
constexpr EEnterReason EEnterReason_MAX = ENTER_CHANGE_ROOM;
constexpr int EEnterReason_ARRAYSIZE = EEnterReason_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EEnterReason_descriptor();
template<typename T>
inline const std::string& EEnterReason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EEnterReason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EEnterReason_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EEnterReason_descriptor(), enum_t_value);
}
inline bool EEnterReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EEnterReason* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EEnterReason>(
    EEnterReason_descriptor(), name, value);
}
enum EDespawnReason : int {
  UNKNOWN = 0,
  KILLED = 1,
  EDespawnReason_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EDespawnReason_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EDespawnReason_IsValid(int value);
constexpr EDespawnReason EDespawnReason_MIN = UNKNOWN;
constexpr EDespawnReason EDespawnReason_MAX = KILLED;
constexpr int EDespawnReason_ARRAYSIZE = EDespawnReason_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EDespawnReason_descriptor();
template<typename T>
inline const std::string& EDespawnReason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EDespawnReason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EDespawnReason_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EDespawnReason_descriptor(), enum_t_value);
}
inline bool EDespawnReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EDespawnReason* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EDespawnReason>(
    EDespawnReason_descriptor(), name, value);
}
// ===================================================================

class C_JwtLoginRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_JwtLoginRequest) */ {
 public:
  inline C_JwtLoginRequest() : C_JwtLoginRequest(nullptr) {}
  ~C_JwtLoginRequest() override;
  explicit PROTOBUF_CONSTEXPR C_JwtLoginRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_JwtLoginRequest(const C_JwtLoginRequest& from);
  C_JwtLoginRequest(C_JwtLoginRequest&& from) noexcept
    : C_JwtLoginRequest() {
    *this = ::std::move(from);
  }

  inline C_JwtLoginRequest& operator=(const C_JwtLoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_JwtLoginRequest& operator=(C_JwtLoginRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_JwtLoginRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_JwtLoginRequest* internal_default_instance() {
    return reinterpret_cast<const C_JwtLoginRequest*>(
               &_C_JwtLoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(C_JwtLoginRequest& a, C_JwtLoginRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(C_JwtLoginRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_JwtLoginRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_JwtLoginRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_JwtLoginRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_JwtLoginRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_JwtLoginRequest& from) {
    C_JwtLoginRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_JwtLoginRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_JwtLoginRequest";
  }
  protected:
  explicit C_JwtLoginRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccessTokenFieldNumber = 1,
  };
  // string accessToken = 1;
  void clear_accesstoken();
  const std::string& accesstoken() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_accesstoken(ArgT0&& arg0, ArgT... args);
  std::string* mutable_accesstoken();
  PROTOBUF_NODISCARD std::string* release_accesstoken();
  void set_allocated_accesstoken(std::string* accesstoken);
  private:
  const std::string& _internal_accesstoken() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_accesstoken(const std::string& value);
  std::string* _internal_mutable_accesstoken();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_JwtLoginRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr accesstoken_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_JwtLoginReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_JwtLoginReply) */ {
 public:
  inline S_JwtLoginReply() : S_JwtLoginReply(nullptr) {}
  ~S_JwtLoginReply() override;
  explicit PROTOBUF_CONSTEXPR S_JwtLoginReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_JwtLoginReply(const S_JwtLoginReply& from);
  S_JwtLoginReply(S_JwtLoginReply&& from) noexcept
    : S_JwtLoginReply() {
    *this = ::std::move(from);
  }

  inline S_JwtLoginReply& operator=(const S_JwtLoginReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_JwtLoginReply& operator=(S_JwtLoginReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_JwtLoginReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_JwtLoginReply* internal_default_instance() {
    return reinterpret_cast<const S_JwtLoginReply*>(
               &_S_JwtLoginReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(S_JwtLoginReply& a, S_JwtLoginReply& b) {
    a.Swap(&b);
  }
  inline void Swap(S_JwtLoginReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_JwtLoginReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_JwtLoginReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_JwtLoginReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_JwtLoginReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_JwtLoginReply& from) {
    S_JwtLoginReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_JwtLoginReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_JwtLoginReply";
  }
  protected:
  explicit S_JwtLoginReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // .Protocol.ELoginResult result = 1;
  void clear_result();
  ::Protocol::ELoginResult result() const;
  void set_result(::Protocol::ELoginResult value);
  private:
  ::Protocol::ELoginResult _internal_result() const;
  void _internal_set_result(::Protocol::ELoginResult value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_JwtLoginReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_CreateCharacterRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_CreateCharacterRequest) */ {
 public:
  inline C_CreateCharacterRequest() : C_CreateCharacterRequest(nullptr) {}
  ~C_CreateCharacterRequest() override;
  explicit PROTOBUF_CONSTEXPR C_CreateCharacterRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_CreateCharacterRequest(const C_CreateCharacterRequest& from);
  C_CreateCharacterRequest(C_CreateCharacterRequest&& from) noexcept
    : C_CreateCharacterRequest() {
    *this = ::std::move(from);
  }

  inline C_CreateCharacterRequest& operator=(const C_CreateCharacterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_CreateCharacterRequest& operator=(C_CreateCharacterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_CreateCharacterRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_CreateCharacterRequest* internal_default_instance() {
    return reinterpret_cast<const C_CreateCharacterRequest*>(
               &_C_CreateCharacterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(C_CreateCharacterRequest& a, C_CreateCharacterRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(C_CreateCharacterRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_CreateCharacterRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_CreateCharacterRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_CreateCharacterRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_CreateCharacterRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_CreateCharacterRequest& from) {
    C_CreateCharacterRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_CreateCharacterRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_CreateCharacterRequest";
  }
  protected:
  explicit C_CreateCharacterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kGenderFieldNumber = 2,
    kRegionFieldNumber = 3,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // .Protocol.EGender gender = 2;
  void clear_gender();
  ::Protocol::EGender gender() const;
  void set_gender(::Protocol::EGender value);
  private:
  ::Protocol::EGender _internal_gender() const;
  void _internal_set_gender(::Protocol::EGender value);
  public:

  // .Protocol.ERegion region = 3;
  void clear_region();
  ::Protocol::ERegion region() const;
  void set_region(::Protocol::ERegion value);
  private:
  ::Protocol::ERegion _internal_region() const;
  void _internal_set_region(::Protocol::ERegion value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_CreateCharacterRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    int gender_;
    int region_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_CreateCharacterReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_CreateCharacterReply) */ {
 public:
  inline S_CreateCharacterReply() : S_CreateCharacterReply(nullptr) {}
  ~S_CreateCharacterReply() override;
  explicit PROTOBUF_CONSTEXPR S_CreateCharacterReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_CreateCharacterReply(const S_CreateCharacterReply& from);
  S_CreateCharacterReply(S_CreateCharacterReply&& from) noexcept
    : S_CreateCharacterReply() {
    *this = ::std::move(from);
  }

  inline S_CreateCharacterReply& operator=(const S_CreateCharacterReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_CreateCharacterReply& operator=(S_CreateCharacterReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_CreateCharacterReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_CreateCharacterReply* internal_default_instance() {
    return reinterpret_cast<const S_CreateCharacterReply*>(
               &_S_CreateCharacterReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(S_CreateCharacterReply& a, S_CreateCharacterReply& b) {
    a.Swap(&b);
  }
  inline void Swap(S_CreateCharacterReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_CreateCharacterReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_CreateCharacterReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_CreateCharacterReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_CreateCharacterReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_CreateCharacterReply& from) {
    S_CreateCharacterReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_CreateCharacterReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_CreateCharacterReply";
  }
  protected:
  explicit S_CreateCharacterReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDetailFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string detail = 2;
  void clear_detail();
  const std::string& detail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_detail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_detail();
  PROTOBUF_NODISCARD std::string* release_detail();
  void set_allocated_detail(std::string* detail);
  private:
  const std::string& _internal_detail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_detail(const std::string& value);
  std::string* _internal_mutable_detail();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_CreateCharacterReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr detail_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_CharacterListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.C_CharacterListRequest) */ {
 public:
  inline C_CharacterListRequest() : C_CharacterListRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR C_CharacterListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_CharacterListRequest(const C_CharacterListRequest& from);
  C_CharacterListRequest(C_CharacterListRequest&& from) noexcept
    : C_CharacterListRequest() {
    *this = ::std::move(from);
  }

  inline C_CharacterListRequest& operator=(const C_CharacterListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_CharacterListRequest& operator=(C_CharacterListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_CharacterListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_CharacterListRequest* internal_default_instance() {
    return reinterpret_cast<const C_CharacterListRequest*>(
               &_C_CharacterListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(C_CharacterListRequest& a, C_CharacterListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(C_CharacterListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_CharacterListRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_CharacterListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_CharacterListRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const C_CharacterListRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const C_CharacterListRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_CharacterListRequest";
  }
  protected:
  explicit C_CharacterListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.C_CharacterListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_CharacterListReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_CharacterListReply) */ {
 public:
  inline S_CharacterListReply() : S_CharacterListReply(nullptr) {}
  ~S_CharacterListReply() override;
  explicit PROTOBUF_CONSTEXPR S_CharacterListReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_CharacterListReply(const S_CharacterListReply& from);
  S_CharacterListReply(S_CharacterListReply&& from) noexcept
    : S_CharacterListReply() {
    *this = ::std::move(from);
  }

  inline S_CharacterListReply& operator=(const S_CharacterListReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_CharacterListReply& operator=(S_CharacterListReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_CharacterListReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_CharacterListReply* internal_default_instance() {
    return reinterpret_cast<const S_CharacterListReply*>(
               &_S_CharacterListReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(S_CharacterListReply& a, S_CharacterListReply& b) {
    a.Swap(&b);
  }
  inline void Swap(S_CharacterListReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_CharacterListReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_CharacterListReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_CharacterListReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_CharacterListReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_CharacterListReply& from) {
    S_CharacterListReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_CharacterListReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_CharacterListReply";
  }
  protected:
  explicit S_CharacterListReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCharactersFieldNumber = 1,
  };
  // repeated .Protocol.CharacterSummaryInfo characters = 1;
  int characters_size() const;
  private:
  int _internal_characters_size() const;
  public:
  void clear_characters();
  ::Protocol::CharacterSummaryInfo* mutable_characters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::CharacterSummaryInfo >*
      mutable_characters();
  private:
  const ::Protocol::CharacterSummaryInfo& _internal_characters(int index) const;
  ::Protocol::CharacterSummaryInfo* _internal_add_characters();
  public:
  const ::Protocol::CharacterSummaryInfo& characters(int index) const;
  ::Protocol::CharacterSummaryInfo* add_characters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::CharacterSummaryInfo >&
      characters() const;

  // @@protoc_insertion_point(class_scope:Protocol.S_CharacterListReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::CharacterSummaryInfo > characters_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_EnterGame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_EnterGame) */ {
 public:
  inline C_EnterGame() : C_EnterGame(nullptr) {}
  ~C_EnterGame() override;
  explicit PROTOBUF_CONSTEXPR C_EnterGame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_EnterGame(const C_EnterGame& from);
  C_EnterGame(C_EnterGame&& from) noexcept
    : C_EnterGame() {
    *this = ::std::move(from);
  }

  inline C_EnterGame& operator=(const C_EnterGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_EnterGame& operator=(C_EnterGame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_EnterGame& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_EnterGame* internal_default_instance() {
    return reinterpret_cast<const C_EnterGame*>(
               &_C_EnterGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(C_EnterGame& a, C_EnterGame& b) {
    a.Swap(&b);
  }
  inline void Swap(C_EnterGame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_EnterGame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_EnterGame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_EnterGame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_EnterGame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_EnterGame& from) {
    C_EnterGame::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_EnterGame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_EnterGame";
  }
  protected:
  explicit C_EnterGame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIndexFieldNumber = 1,
  };
  // int32 playerIndex = 1;
  void clear_playerindex();
  int32_t playerindex() const;
  void set_playerindex(int32_t value);
  private:
  int32_t _internal_playerindex() const;
  void _internal_set_playerindex(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_EnterGame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t playerindex_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_EnterGame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_EnterGame) */ {
 public:
  inline S_EnterGame() : S_EnterGame(nullptr) {}
  ~S_EnterGame() override;
  explicit PROTOBUF_CONSTEXPR S_EnterGame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_EnterGame(const S_EnterGame& from);
  S_EnterGame(S_EnterGame&& from) noexcept
    : S_EnterGame() {
    *this = ::std::move(from);
  }

  inline S_EnterGame& operator=(const S_EnterGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_EnterGame& operator=(S_EnterGame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_EnterGame& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_EnterGame* internal_default_instance() {
    return reinterpret_cast<const S_EnterGame*>(
               &_S_EnterGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(S_EnterGame& a, S_EnterGame& b) {
    a.Swap(&b);
  }
  inline void Swap(S_EnterGame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_EnterGame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_EnterGame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_EnterGame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_EnterGame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_EnterGame& from) {
    S_EnterGame::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_EnterGame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_EnterGame";
  }
  protected:
  explicit S_EnterGame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // int32 success = 1;
  void clear_success();
  int32_t success() const;
  void set_success(int32_t value);
  private:
  int32_t _internal_success() const;
  void _internal_set_success(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_EnterGame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_PlayerList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_PlayerList) */ {
 public:
  inline S_PlayerList() : S_PlayerList(nullptr) {}
  ~S_PlayerList() override;
  explicit PROTOBUF_CONSTEXPR S_PlayerList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_PlayerList(const S_PlayerList& from);
  S_PlayerList(S_PlayerList&& from) noexcept
    : S_PlayerList() {
    *this = ::std::move(from);
  }

  inline S_PlayerList& operator=(const S_PlayerList& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_PlayerList& operator=(S_PlayerList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_PlayerList& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_PlayerList* internal_default_instance() {
    return reinterpret_cast<const S_PlayerList*>(
               &_S_PlayerList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(S_PlayerList& a, S_PlayerList& b) {
    a.Swap(&b);
  }
  inline void Swap(S_PlayerList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_PlayerList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_PlayerList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_PlayerList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_PlayerList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_PlayerList& from) {
    S_PlayerList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_PlayerList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_PlayerList";
  }
  protected:
  explicit S_PlayerList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 2,
    kMyPlayerIdFieldNumber = 1,
  };
  // repeated .Protocol.PlayerInfo players = 2;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::Protocol::PlayerInfo* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerInfo >*
      mutable_players();
  private:
  const ::Protocol::PlayerInfo& _internal_players(int index) const;
  ::Protocol::PlayerInfo* _internal_add_players();
  public:
  const ::Protocol::PlayerInfo& players(int index) const;
  ::Protocol::PlayerInfo* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerInfo >&
      players() const;

  // int32 myPlayerId = 1;
  void clear_myplayerid();
  int32_t myplayerid() const;
  void set_myplayerid(int32_t value);
  private:
  int32_t _internal_myplayerid() const;
  void _internal_set_myplayerid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_PlayerList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerInfo > players_;
    int32_t myplayerid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_BroadcastPlayerEnter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_BroadcastPlayerEnter) */ {
 public:
  inline S_BroadcastPlayerEnter() : S_BroadcastPlayerEnter(nullptr) {}
  ~S_BroadcastPlayerEnter() override;
  explicit PROTOBUF_CONSTEXPR S_BroadcastPlayerEnter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_BroadcastPlayerEnter(const S_BroadcastPlayerEnter& from);
  S_BroadcastPlayerEnter(S_BroadcastPlayerEnter&& from) noexcept
    : S_BroadcastPlayerEnter() {
    *this = ::std::move(from);
  }

  inline S_BroadcastPlayerEnter& operator=(const S_BroadcastPlayerEnter& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_BroadcastPlayerEnter& operator=(S_BroadcastPlayerEnter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_BroadcastPlayerEnter& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_BroadcastPlayerEnter* internal_default_instance() {
    return reinterpret_cast<const S_BroadcastPlayerEnter*>(
               &_S_BroadcastPlayerEnter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(S_BroadcastPlayerEnter& a, S_BroadcastPlayerEnter& b) {
    a.Swap(&b);
  }
  inline void Swap(S_BroadcastPlayerEnter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_BroadcastPlayerEnter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_BroadcastPlayerEnter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_BroadcastPlayerEnter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_BroadcastPlayerEnter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_BroadcastPlayerEnter& from) {
    S_BroadcastPlayerEnter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_BroadcastPlayerEnter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_BroadcastPlayerEnter";
  }
  protected:
  explicit S_BroadcastPlayerEnter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerFieldNumber = 1,
  };
  // .Protocol.PlayerInfo player = 1;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::Protocol::PlayerInfo& player() const;
  PROTOBUF_NODISCARD ::Protocol::PlayerInfo* release_player();
  ::Protocol::PlayerInfo* mutable_player();
  void set_allocated_player(::Protocol::PlayerInfo* player);
  private:
  const ::Protocol::PlayerInfo& _internal_player() const;
  ::Protocol::PlayerInfo* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::Protocol::PlayerInfo* player);
  ::Protocol::PlayerInfo* unsafe_arena_release_player();

  // @@protoc_insertion_point(class_scope:Protocol.S_BroadcastPlayerEnter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::PlayerInfo* player_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_LeaveGame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_LeaveGame) */ {
 public:
  inline C_LeaveGame() : C_LeaveGame(nullptr) {}
  ~C_LeaveGame() override;
  explicit PROTOBUF_CONSTEXPR C_LeaveGame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_LeaveGame(const C_LeaveGame& from);
  C_LeaveGame(C_LeaveGame&& from) noexcept
    : C_LeaveGame() {
    *this = ::std::move(from);
  }

  inline C_LeaveGame& operator=(const C_LeaveGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_LeaveGame& operator=(C_LeaveGame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_LeaveGame& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_LeaveGame* internal_default_instance() {
    return reinterpret_cast<const C_LeaveGame*>(
               &_C_LeaveGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(C_LeaveGame& a, C_LeaveGame& b) {
    a.Swap(&b);
  }
  inline void Swap(C_LeaveGame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_LeaveGame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_LeaveGame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_LeaveGame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_LeaveGame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_LeaveGame& from) {
    C_LeaveGame::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_LeaveGame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_LeaveGame";
  }
  protected:
  explicit C_LeaveGame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReasonFieldNumber = 1,
  };
  // .Protocol.ELeaveReason reason = 1;
  void clear_reason();
  ::Protocol::ELeaveReason reason() const;
  void set_reason(::Protocol::ELeaveReason value);
  private:
  ::Protocol::ELeaveReason _internal_reason() const;
  void _internal_set_reason(::Protocol::ELeaveReason value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_LeaveGame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int reason_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_LeaveGame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_LeaveGame) */ {
 public:
  inline S_LeaveGame() : S_LeaveGame(nullptr) {}
  ~S_LeaveGame() override;
  explicit PROTOBUF_CONSTEXPR S_LeaveGame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_LeaveGame(const S_LeaveGame& from);
  S_LeaveGame(S_LeaveGame&& from) noexcept
    : S_LeaveGame() {
    *this = ::std::move(from);
  }

  inline S_LeaveGame& operator=(const S_LeaveGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_LeaveGame& operator=(S_LeaveGame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_LeaveGame& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_LeaveGame* internal_default_instance() {
    return reinterpret_cast<const S_LeaveGame*>(
               &_S_LeaveGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(S_LeaveGame& a, S_LeaveGame& b) {
    a.Swap(&b);
  }
  inline void Swap(S_LeaveGame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_LeaveGame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_LeaveGame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_LeaveGame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_LeaveGame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_LeaveGame& from) {
    S_LeaveGame::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_LeaveGame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_LeaveGame";
  }
  protected:
  explicit S_LeaveGame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // int32 success = 1;
  void clear_success();
  int32_t success() const;
  void set_success(int32_t value);
  private:
  int32_t _internal_success() const;
  void _internal_set_success(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_LeaveGame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_BroadcastPlayerLeave final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_BroadcastPlayerLeave) */ {
 public:
  inline S_BroadcastPlayerLeave() : S_BroadcastPlayerLeave(nullptr) {}
  ~S_BroadcastPlayerLeave() override;
  explicit PROTOBUF_CONSTEXPR S_BroadcastPlayerLeave(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_BroadcastPlayerLeave(const S_BroadcastPlayerLeave& from);
  S_BroadcastPlayerLeave(S_BroadcastPlayerLeave&& from) noexcept
    : S_BroadcastPlayerLeave() {
    *this = ::std::move(from);
  }

  inline S_BroadcastPlayerLeave& operator=(const S_BroadcastPlayerLeave& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_BroadcastPlayerLeave& operator=(S_BroadcastPlayerLeave&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_BroadcastPlayerLeave& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_BroadcastPlayerLeave* internal_default_instance() {
    return reinterpret_cast<const S_BroadcastPlayerLeave*>(
               &_S_BroadcastPlayerLeave_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(S_BroadcastPlayerLeave& a, S_BroadcastPlayerLeave& b) {
    a.Swap(&b);
  }
  inline void Swap(S_BroadcastPlayerLeave* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_BroadcastPlayerLeave* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_BroadcastPlayerLeave* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_BroadcastPlayerLeave>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_BroadcastPlayerLeave& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_BroadcastPlayerLeave& from) {
    S_BroadcastPlayerLeave::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_BroadcastPlayerLeave* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_BroadcastPlayerLeave";
  }
  protected:
  explicit S_BroadcastPlayerLeave(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kReasonFieldNumber = 2,
  };
  // int32 playerId = 1;
  void clear_playerid();
  int32_t playerid() const;
  void set_playerid(int32_t value);
  private:
  int32_t _internal_playerid() const;
  void _internal_set_playerid(int32_t value);
  public:

  // .Protocol.ELeaveReason reason = 2;
  void clear_reason();
  ::Protocol::ELeaveReason reason() const;
  void set_reason(::Protocol::ELeaveReason value);
  private:
  ::Protocol::ELeaveReason _internal_reason() const;
  void _internal_set_reason(::Protocol::ELeaveReason value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_BroadcastPlayerLeave)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t playerid_;
    int reason_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_PlayerMoveRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_PlayerMoveRequest) */ {
 public:
  inline C_PlayerMoveRequest() : C_PlayerMoveRequest(nullptr) {}
  ~C_PlayerMoveRequest() override;
  explicit PROTOBUF_CONSTEXPR C_PlayerMoveRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_PlayerMoveRequest(const C_PlayerMoveRequest& from);
  C_PlayerMoveRequest(C_PlayerMoveRequest&& from) noexcept
    : C_PlayerMoveRequest() {
    *this = ::std::move(from);
  }

  inline C_PlayerMoveRequest& operator=(const C_PlayerMoveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_PlayerMoveRequest& operator=(C_PlayerMoveRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_PlayerMoveRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_PlayerMoveRequest* internal_default_instance() {
    return reinterpret_cast<const C_PlayerMoveRequest*>(
               &_C_PlayerMoveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(C_PlayerMoveRequest& a, C_PlayerMoveRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(C_PlayerMoveRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_PlayerMoveRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_PlayerMoveRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_PlayerMoveRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_PlayerMoveRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_PlayerMoveRequest& from) {
    C_PlayerMoveRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_PlayerMoveRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_PlayerMoveRequest";
  }
  protected:
  explicit C_PlayerMoveRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClickWorldPosFieldNumber = 1,
  };
  // .Protocol.Vector2Info clickWorldPos = 1;
  bool has_clickworldpos() const;
  private:
  bool _internal_has_clickworldpos() const;
  public:
  void clear_clickworldpos();
  const ::Protocol::Vector2Info& clickworldpos() const;
  PROTOBUF_NODISCARD ::Protocol::Vector2Info* release_clickworldpos();
  ::Protocol::Vector2Info* mutable_clickworldpos();
  void set_allocated_clickworldpos(::Protocol::Vector2Info* clickworldpos);
  private:
  const ::Protocol::Vector2Info& _internal_clickworldpos() const;
  ::Protocol::Vector2Info* _internal_mutable_clickworldpos();
  public:
  void unsafe_arena_set_allocated_clickworldpos(
      ::Protocol::Vector2Info* clickworldpos);
  ::Protocol::Vector2Info* unsafe_arena_release_clickworldpos();

  // @@protoc_insertion_point(class_scope:Protocol.C_PlayerMoveRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::Vector2Info* clickworldpos_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_PlayerMoveReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_PlayerMoveReply) */ {
 public:
  inline S_PlayerMoveReply() : S_PlayerMoveReply(nullptr) {}
  ~S_PlayerMoveReply() override;
  explicit PROTOBUF_CONSTEXPR S_PlayerMoveReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_PlayerMoveReply(const S_PlayerMoveReply& from);
  S_PlayerMoveReply(S_PlayerMoveReply&& from) noexcept
    : S_PlayerMoveReply() {
    *this = ::std::move(from);
  }

  inline S_PlayerMoveReply& operator=(const S_PlayerMoveReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_PlayerMoveReply& operator=(S_PlayerMoveReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_PlayerMoveReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_PlayerMoveReply* internal_default_instance() {
    return reinterpret_cast<const S_PlayerMoveReply*>(
               &_S_PlayerMoveReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(S_PlayerMoveReply& a, S_PlayerMoveReply& b) {
    a.Swap(&b);
  }
  inline void Swap(S_PlayerMoveReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_PlayerMoveReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_PlayerMoveReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_PlayerMoveReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_PlayerMoveReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_PlayerMoveReply& from) {
    S_PlayerMoveReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_PlayerMoveReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_PlayerMoveReply";
  }
  protected:
  explicit S_PlayerMoveReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewPosFieldNumber = 5,
    kPlayerIdFieldNumber = 1,
    kClientSeqFieldNumber = 2,
    kResultFieldNumber = 3,
    kTickFieldNumber = 4,
    kDirectionFieldNumber = 6,
  };
  // .Protocol.Vector2Info newPos = 5;
  bool has_newpos() const;
  private:
  bool _internal_has_newpos() const;
  public:
  void clear_newpos();
  const ::Protocol::Vector2Info& newpos() const;
  PROTOBUF_NODISCARD ::Protocol::Vector2Info* release_newpos();
  ::Protocol::Vector2Info* mutable_newpos();
  void set_allocated_newpos(::Protocol::Vector2Info* newpos);
  private:
  const ::Protocol::Vector2Info& _internal_newpos() const;
  ::Protocol::Vector2Info* _internal_mutable_newpos();
  public:
  void unsafe_arena_set_allocated_newpos(
      ::Protocol::Vector2Info* newpos);
  ::Protocol::Vector2Info* unsafe_arena_release_newpos();

  // int32 playerId = 1;
  void clear_playerid();
  int32_t playerid() const;
  void set_playerid(int32_t value);
  private:
  int32_t _internal_playerid() const;
  void _internal_set_playerid(int32_t value);
  public:

  // int32 clientSeq = 2;
  void clear_clientseq();
  int32_t clientseq() const;
  void set_clientseq(int32_t value);
  private:
  int32_t _internal_clientseq() const;
  void _internal_set_clientseq(int32_t value);
  public:

  // .Protocol.EMoveResult result = 3;
  void clear_result();
  ::Protocol::EMoveResult result() const;
  void set_result(::Protocol::EMoveResult value);
  private:
  ::Protocol::EMoveResult _internal_result() const;
  void _internal_set_result(::Protocol::EMoveResult value);
  public:

  // int32 tick = 4;
  void clear_tick();
  int32_t tick() const;
  void set_tick(int32_t value);
  private:
  int32_t _internal_tick() const;
  void _internal_set_tick(int32_t value);
  public:

  // .Protocol.EDirection direction = 6;
  void clear_direction();
  ::Protocol::EDirection direction() const;
  void set_direction(::Protocol::EDirection value);
  private:
  ::Protocol::EDirection _internal_direction() const;
  void _internal_set_direction(::Protocol::EDirection value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_PlayerMoveReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::Vector2Info* newpos_;
    int32_t playerid_;
    int32_t clientseq_;
    int result_;
    int32_t tick_;
    int direction_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_BroadcastPlayerMove final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_BroadcastPlayerMove) */ {
 public:
  inline S_BroadcastPlayerMove() : S_BroadcastPlayerMove(nullptr) {}
  ~S_BroadcastPlayerMove() override;
  explicit PROTOBUF_CONSTEXPR S_BroadcastPlayerMove(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_BroadcastPlayerMove(const S_BroadcastPlayerMove& from);
  S_BroadcastPlayerMove(S_BroadcastPlayerMove&& from) noexcept
    : S_BroadcastPlayerMove() {
    *this = ::std::move(from);
  }

  inline S_BroadcastPlayerMove& operator=(const S_BroadcastPlayerMove& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_BroadcastPlayerMove& operator=(S_BroadcastPlayerMove&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_BroadcastPlayerMove& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_BroadcastPlayerMove* internal_default_instance() {
    return reinterpret_cast<const S_BroadcastPlayerMove*>(
               &_S_BroadcastPlayerMove_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(S_BroadcastPlayerMove& a, S_BroadcastPlayerMove& b) {
    a.Swap(&b);
  }
  inline void Swap(S_BroadcastPlayerMove* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_BroadcastPlayerMove* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_BroadcastPlayerMove* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_BroadcastPlayerMove>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_BroadcastPlayerMove& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_BroadcastPlayerMove& from) {
    S_BroadcastPlayerMove::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_BroadcastPlayerMove* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_BroadcastPlayerMove";
  }
  protected:
  explicit S_BroadcastPlayerMove(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerMovesFieldNumber = 2,
    kTickFieldNumber = 1,
  };
  // repeated .Protocol.PlayerMoveInfo playerMoves = 2;
  int playermoves_size() const;
  private:
  int _internal_playermoves_size() const;
  public:
  void clear_playermoves();
  ::Protocol::PlayerMoveInfo* mutable_playermoves(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerMoveInfo >*
      mutable_playermoves();
  private:
  const ::Protocol::PlayerMoveInfo& _internal_playermoves(int index) const;
  ::Protocol::PlayerMoveInfo* _internal_add_playermoves();
  public:
  const ::Protocol::PlayerMoveInfo& playermoves(int index) const;
  ::Protocol::PlayerMoveInfo* add_playermoves();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerMoveInfo >&
      playermoves() const;

  // int32 tick = 1;
  void clear_tick();
  int32_t tick() const;
  void set_tick(int32_t value);
  private:
  int32_t _internal_tick() const;
  void _internal_set_tick(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_BroadcastPlayerMove)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerMoveInfo > playermoves_;
    int32_t tick_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_ChangeRoomBegin final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_ChangeRoomBegin) */ {
 public:
  inline S_ChangeRoomBegin() : S_ChangeRoomBegin(nullptr) {}
  ~S_ChangeRoomBegin() override;
  explicit PROTOBUF_CONSTEXPR S_ChangeRoomBegin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_ChangeRoomBegin(const S_ChangeRoomBegin& from);
  S_ChangeRoomBegin(S_ChangeRoomBegin&& from) noexcept
    : S_ChangeRoomBegin() {
    *this = ::std::move(from);
  }

  inline S_ChangeRoomBegin& operator=(const S_ChangeRoomBegin& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_ChangeRoomBegin& operator=(S_ChangeRoomBegin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_ChangeRoomBegin& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_ChangeRoomBegin* internal_default_instance() {
    return reinterpret_cast<const S_ChangeRoomBegin*>(
               &_S_ChangeRoomBegin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(S_ChangeRoomBegin& a, S_ChangeRoomBegin& b) {
    a.Swap(&b);
  }
  inline void Swap(S_ChangeRoomBegin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_ChangeRoomBegin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_ChangeRoomBegin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_ChangeRoomBegin>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_ChangeRoomBegin& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_ChangeRoomBegin& from) {
    S_ChangeRoomBegin::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_ChangeRoomBegin* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_ChangeRoomBegin";
  }
  protected:
  explicit S_ChangeRoomBegin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransitionIdFieldNumber = 1,
    kMapIdFieldNumber = 2,
  };
  // int32 transitionId = 1;
  void clear_transitionid();
  int32_t transitionid() const;
  void set_transitionid(int32_t value);
  private:
  int32_t _internal_transitionid() const;
  void _internal_set_transitionid(int32_t value);
  public:

  // int32 mapId = 2;
  void clear_mapid();
  int32_t mapid() const;
  void set_mapid(int32_t value);
  private:
  int32_t _internal_mapid() const;
  void _internal_set_mapid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_ChangeRoomBegin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t transitionid_;
    int32_t mapid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_ChangeRoomReady final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_ChangeRoomReady) */ {
 public:
  inline C_ChangeRoomReady() : C_ChangeRoomReady(nullptr) {}
  ~C_ChangeRoomReady() override;
  explicit PROTOBUF_CONSTEXPR C_ChangeRoomReady(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_ChangeRoomReady(const C_ChangeRoomReady& from);
  C_ChangeRoomReady(C_ChangeRoomReady&& from) noexcept
    : C_ChangeRoomReady() {
    *this = ::std::move(from);
  }

  inline C_ChangeRoomReady& operator=(const C_ChangeRoomReady& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_ChangeRoomReady& operator=(C_ChangeRoomReady&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_ChangeRoomReady& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_ChangeRoomReady* internal_default_instance() {
    return reinterpret_cast<const C_ChangeRoomReady*>(
               &_C_ChangeRoomReady_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(C_ChangeRoomReady& a, C_ChangeRoomReady& b) {
    a.Swap(&b);
  }
  inline void Swap(C_ChangeRoomReady* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_ChangeRoomReady* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_ChangeRoomReady* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_ChangeRoomReady>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_ChangeRoomReady& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_ChangeRoomReady& from) {
    C_ChangeRoomReady::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_ChangeRoomReady* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_ChangeRoomReady";
  }
  protected:
  explicit C_ChangeRoomReady(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransitionIdFieldNumber = 1,
  };
  // int32 transitionId = 1;
  void clear_transitionid();
  int32_t transitionid() const;
  void set_transitionid(int32_t value);
  private:
  int32_t _internal_transitionid() const;
  void _internal_set_transitionid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_ChangeRoomReady)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t transitionid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_ChangeRoomCommit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_ChangeRoomCommit) */ {
 public:
  inline S_ChangeRoomCommit() : S_ChangeRoomCommit(nullptr) {}
  ~S_ChangeRoomCommit() override;
  explicit PROTOBUF_CONSTEXPR S_ChangeRoomCommit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_ChangeRoomCommit(const S_ChangeRoomCommit& from);
  S_ChangeRoomCommit(S_ChangeRoomCommit&& from) noexcept
    : S_ChangeRoomCommit() {
    *this = ::std::move(from);
  }

  inline S_ChangeRoomCommit& operator=(const S_ChangeRoomCommit& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_ChangeRoomCommit& operator=(S_ChangeRoomCommit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_ChangeRoomCommit& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_ChangeRoomCommit* internal_default_instance() {
    return reinterpret_cast<const S_ChangeRoomCommit*>(
               &_S_ChangeRoomCommit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(S_ChangeRoomCommit& a, S_ChangeRoomCommit& b) {
    a.Swap(&b);
  }
  inline void Swap(S_ChangeRoomCommit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_ChangeRoomCommit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_ChangeRoomCommit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_ChangeRoomCommit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_ChangeRoomCommit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_ChangeRoomCommit& from) {
    S_ChangeRoomCommit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_ChangeRoomCommit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_ChangeRoomCommit";
  }
  protected:
  explicit S_ChangeRoomCommit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSnapshotsFieldNumber = 2,
    kTransitionIdFieldNumber = 1,
  };
  // .Protocol.S_PlayerList snapshots = 2;
  bool has_snapshots() const;
  private:
  bool _internal_has_snapshots() const;
  public:
  void clear_snapshots();
  const ::Protocol::S_PlayerList& snapshots() const;
  PROTOBUF_NODISCARD ::Protocol::S_PlayerList* release_snapshots();
  ::Protocol::S_PlayerList* mutable_snapshots();
  void set_allocated_snapshots(::Protocol::S_PlayerList* snapshots);
  private:
  const ::Protocol::S_PlayerList& _internal_snapshots() const;
  ::Protocol::S_PlayerList* _internal_mutable_snapshots();
  public:
  void unsafe_arena_set_allocated_snapshots(
      ::Protocol::S_PlayerList* snapshots);
  ::Protocol::S_PlayerList* unsafe_arena_release_snapshots();

  // int32 transitionId = 1;
  void clear_transitionid();
  int32_t transitionid() const;
  void set_transitionid(int32_t value);
  private:
  int32_t _internal_transitionid() const;
  void _internal_set_transitionid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_ChangeRoomCommit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::S_PlayerList* snapshots_;
    int32_t transitionid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_SpawnMonster final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_SpawnMonster) */ {
 public:
  inline S_SpawnMonster() : S_SpawnMonster(nullptr) {}
  ~S_SpawnMonster() override;
  explicit PROTOBUF_CONSTEXPR S_SpawnMonster(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_SpawnMonster(const S_SpawnMonster& from);
  S_SpawnMonster(S_SpawnMonster&& from) noexcept
    : S_SpawnMonster() {
    *this = ::std::move(from);
  }

  inline S_SpawnMonster& operator=(const S_SpawnMonster& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_SpawnMonster& operator=(S_SpawnMonster&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_SpawnMonster& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_SpawnMonster* internal_default_instance() {
    return reinterpret_cast<const S_SpawnMonster*>(
               &_S_SpawnMonster_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(S_SpawnMonster& a, S_SpawnMonster& b) {
    a.Swap(&b);
  }
  inline void Swap(S_SpawnMonster* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_SpawnMonster* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_SpawnMonster* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_SpawnMonster>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_SpawnMonster& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_SpawnMonster& from) {
    S_SpawnMonster::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_SpawnMonster* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_SpawnMonster";
  }
  protected:
  explicit S_SpawnMonster(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMonsterIdFieldNumber = 1,
    kMonsterTypeIdFieldNumber = 2,
    kXFieldNumber = 3,
    kYFieldNumber = 4,
    kDirFieldNumber = 5,
  };
  // int32 monsterId = 1;
  void clear_monsterid();
  int32_t monsterid() const;
  void set_monsterid(int32_t value);
  private:
  int32_t _internal_monsterid() const;
  void _internal_set_monsterid(int32_t value);
  public:

  // int32 monsterTypeId = 2;
  void clear_monstertypeid();
  int32_t monstertypeid() const;
  void set_monstertypeid(int32_t value);
  private:
  int32_t _internal_monstertypeid() const;
  void _internal_set_monstertypeid(int32_t value);
  public:

  // int32 x = 3;
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // int32 y = 4;
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // .Protocol.EDirection dir = 5;
  void clear_dir();
  ::Protocol::EDirection dir() const;
  void set_dir(::Protocol::EDirection value);
  private:
  ::Protocol::EDirection _internal_dir() const;
  void _internal_set_dir(::Protocol::EDirection value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_SpawnMonster)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t monsterid_;
    int32_t monstertypeid_;
    int32_t x_;
    int32_t y_;
    int dir_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_DespawnMonster final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_DespawnMonster) */ {
 public:
  inline S_DespawnMonster() : S_DespawnMonster(nullptr) {}
  ~S_DespawnMonster() override;
  explicit PROTOBUF_CONSTEXPR S_DespawnMonster(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_DespawnMonster(const S_DespawnMonster& from);
  S_DespawnMonster(S_DespawnMonster&& from) noexcept
    : S_DespawnMonster() {
    *this = ::std::move(from);
  }

  inline S_DespawnMonster& operator=(const S_DespawnMonster& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_DespawnMonster& operator=(S_DespawnMonster&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_DespawnMonster& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_DespawnMonster* internal_default_instance() {
    return reinterpret_cast<const S_DespawnMonster*>(
               &_S_DespawnMonster_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(S_DespawnMonster& a, S_DespawnMonster& b) {
    a.Swap(&b);
  }
  inline void Swap(S_DespawnMonster* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_DespawnMonster* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_DespawnMonster* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_DespawnMonster>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_DespawnMonster& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_DespawnMonster& from) {
    S_DespawnMonster::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_DespawnMonster* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_DespawnMonster";
  }
  protected:
  explicit S_DespawnMonster(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMonsterIdFieldNumber = 1,
    kReasonFieldNumber = 2,
  };
  // int32 monsterId = 1;
  void clear_monsterid();
  int32_t monsterid() const;
  void set_monsterid(int32_t value);
  private:
  int32_t _internal_monsterid() const;
  void _internal_set_monsterid(int32_t value);
  public:

  // .Protocol.EDespawnReason reason = 2;
  void clear_reason();
  ::Protocol::EDespawnReason reason() const;
  void set_reason(::Protocol::EDespawnReason value);
  private:
  ::Protocol::EDespawnReason _internal_reason() const;
  void _internal_set_reason(::Protocol::EDespawnReason value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_DespawnMonster)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t monsterid_;
    int reason_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_BroadcastMonsterMove final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_BroadcastMonsterMove) */ {
 public:
  inline S_BroadcastMonsterMove() : S_BroadcastMonsterMove(nullptr) {}
  ~S_BroadcastMonsterMove() override;
  explicit PROTOBUF_CONSTEXPR S_BroadcastMonsterMove(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_BroadcastMonsterMove(const S_BroadcastMonsterMove& from);
  S_BroadcastMonsterMove(S_BroadcastMonsterMove&& from) noexcept
    : S_BroadcastMonsterMove() {
    *this = ::std::move(from);
  }

  inline S_BroadcastMonsterMove& operator=(const S_BroadcastMonsterMove& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_BroadcastMonsterMove& operator=(S_BroadcastMonsterMove&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_BroadcastMonsterMove& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_BroadcastMonsterMove* internal_default_instance() {
    return reinterpret_cast<const S_BroadcastMonsterMove*>(
               &_S_BroadcastMonsterMove_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(S_BroadcastMonsterMove& a, S_BroadcastMonsterMove& b) {
    a.Swap(&b);
  }
  inline void Swap(S_BroadcastMonsterMove* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_BroadcastMonsterMove* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_BroadcastMonsterMove* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_BroadcastMonsterMove>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_BroadcastMonsterMove& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_BroadcastMonsterMove& from) {
    S_BroadcastMonsterMove::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_BroadcastMonsterMove* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_BroadcastMonsterMove";
  }
  protected:
  explicit S_BroadcastMonsterMove(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMonsterIdFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
    kDirFieldNumber = 4,
  };
  // int32 monsterId = 1;
  void clear_monsterid();
  int32_t monsterid() const;
  void set_monsterid(int32_t value);
  private:
  int32_t _internal_monsterid() const;
  void _internal_set_monsterid(int32_t value);
  public:

  // int32 x = 2;
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // int32 y = 3;
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // .Protocol.EDirection dir = 4;
  void clear_dir();
  ::Protocol::EDirection dir() const;
  void set_dir(::Protocol::EDirection value);
  private:
  ::Protocol::EDirection _internal_dir() const;
  void _internal_set_dir(::Protocol::EDirection value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_BroadcastMonsterMove)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t monsterid_;
    int32_t x_;
    int32_t y_;
    int dir_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_BroadcastMonsterAttack final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_BroadcastMonsterAttack) */ {
 public:
  inline S_BroadcastMonsterAttack() : S_BroadcastMonsterAttack(nullptr) {}
  ~S_BroadcastMonsterAttack() override;
  explicit PROTOBUF_CONSTEXPR S_BroadcastMonsterAttack(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_BroadcastMonsterAttack(const S_BroadcastMonsterAttack& from);
  S_BroadcastMonsterAttack(S_BroadcastMonsterAttack&& from) noexcept
    : S_BroadcastMonsterAttack() {
    *this = ::std::move(from);
  }

  inline S_BroadcastMonsterAttack& operator=(const S_BroadcastMonsterAttack& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_BroadcastMonsterAttack& operator=(S_BroadcastMonsterAttack&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_BroadcastMonsterAttack& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_BroadcastMonsterAttack* internal_default_instance() {
    return reinterpret_cast<const S_BroadcastMonsterAttack*>(
               &_S_BroadcastMonsterAttack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(S_BroadcastMonsterAttack& a, S_BroadcastMonsterAttack& b) {
    a.Swap(&b);
  }
  inline void Swap(S_BroadcastMonsterAttack* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_BroadcastMonsterAttack* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_BroadcastMonsterAttack* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_BroadcastMonsterAttack>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_BroadcastMonsterAttack& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_BroadcastMonsterAttack& from) {
    S_BroadcastMonsterAttack::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_BroadcastMonsterAttack* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_BroadcastMonsterAttack";
  }
  protected:
  explicit S_BroadcastMonsterAttack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMonsterIdFieldNumber = 1,
    kTargetPidFieldNumber = 2,
  };
  // int32 monsterId = 1;
  void clear_monsterid();
  int32_t monsterid() const;
  void set_monsterid(int32_t value);
  private:
  int32_t _internal_monsterid() const;
  void _internal_set_monsterid(int32_t value);
  public:

  // int32 targetPid = 2;
  void clear_targetpid();
  int32_t targetpid() const;
  void set_targetpid(int32_t value);
  private:
  int32_t _internal_targetpid() const;
  void _internal_set_targetpid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_BroadcastMonsterAttack)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t monsterid_;
    int32_t targetpid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_BroadcastMonsterDeath final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_BroadcastMonsterDeath) */ {
 public:
  inline S_BroadcastMonsterDeath() : S_BroadcastMonsterDeath(nullptr) {}
  ~S_BroadcastMonsterDeath() override;
  explicit PROTOBUF_CONSTEXPR S_BroadcastMonsterDeath(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_BroadcastMonsterDeath(const S_BroadcastMonsterDeath& from);
  S_BroadcastMonsterDeath(S_BroadcastMonsterDeath&& from) noexcept
    : S_BroadcastMonsterDeath() {
    *this = ::std::move(from);
  }

  inline S_BroadcastMonsterDeath& operator=(const S_BroadcastMonsterDeath& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_BroadcastMonsterDeath& operator=(S_BroadcastMonsterDeath&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_BroadcastMonsterDeath& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_BroadcastMonsterDeath* internal_default_instance() {
    return reinterpret_cast<const S_BroadcastMonsterDeath*>(
               &_S_BroadcastMonsterDeath_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(S_BroadcastMonsterDeath& a, S_BroadcastMonsterDeath& b) {
    a.Swap(&b);
  }
  inline void Swap(S_BroadcastMonsterDeath* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_BroadcastMonsterDeath* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_BroadcastMonsterDeath* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_BroadcastMonsterDeath>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_BroadcastMonsterDeath& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_BroadcastMonsterDeath& from) {
    S_BroadcastMonsterDeath::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_BroadcastMonsterDeath* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_BroadcastMonsterDeath";
  }
  protected:
  explicit S_BroadcastMonsterDeath(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMonsterIdFieldNumber = 1,
  };
  // int32 monsterId = 1;
  void clear_monsterid();
  int32_t monsterid() const;
  void set_monsterid(int32_t value);
  private:
  int32_t _internal_monsterid() const;
  void _internal_set_monsterid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_BroadcastMonsterDeath)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t monsterid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class Vector2Info final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.Vector2Info) */ {
 public:
  inline Vector2Info() : Vector2Info(nullptr) {}
  ~Vector2Info() override;
  explicit PROTOBUF_CONSTEXPR Vector2Info(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vector2Info(const Vector2Info& from);
  Vector2Info(Vector2Info&& from) noexcept
    : Vector2Info() {
    *this = ::std::move(from);
  }

  inline Vector2Info& operator=(const Vector2Info& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector2Info& operator=(Vector2Info&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vector2Info& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vector2Info* internal_default_instance() {
    return reinterpret_cast<const Vector2Info*>(
               &_Vector2Info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(Vector2Info& a, Vector2Info& b) {
    a.Swap(&b);
  }
  inline void Swap(Vector2Info* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector2Info* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vector2Info* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vector2Info>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vector2Info& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Vector2Info& from) {
    Vector2Info::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector2Info* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.Vector2Info";
  }
  protected:
  explicit Vector2Info(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // int32 x = 1;
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // int32 y = 2;
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.Vector2Info)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t x_;
    int32_t y_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class PlayerMoveInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.PlayerMoveInfo) */ {
 public:
  inline PlayerMoveInfo() : PlayerMoveInfo(nullptr) {}
  ~PlayerMoveInfo() override;
  explicit PROTOBUF_CONSTEXPR PlayerMoveInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerMoveInfo(const PlayerMoveInfo& from);
  PlayerMoveInfo(PlayerMoveInfo&& from) noexcept
    : PlayerMoveInfo() {
    *this = ::std::move(from);
  }

  inline PlayerMoveInfo& operator=(const PlayerMoveInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerMoveInfo& operator=(PlayerMoveInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerMoveInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerMoveInfo* internal_default_instance() {
    return reinterpret_cast<const PlayerMoveInfo*>(
               &_PlayerMoveInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(PlayerMoveInfo& a, PlayerMoveInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerMoveInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerMoveInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerMoveInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerMoveInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerMoveInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlayerMoveInfo& from) {
    PlayerMoveInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerMoveInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.PlayerMoveInfo";
  }
  protected:
  explicit PlayerMoveInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewPosFieldNumber = 3,
    kPlayerIdFieldNumber = 1,
    kDirectionFieldNumber = 2,
  };
  // .Protocol.Vector2Info newPos = 3;
  bool has_newpos() const;
  private:
  bool _internal_has_newpos() const;
  public:
  void clear_newpos();
  const ::Protocol::Vector2Info& newpos() const;
  PROTOBUF_NODISCARD ::Protocol::Vector2Info* release_newpos();
  ::Protocol::Vector2Info* mutable_newpos();
  void set_allocated_newpos(::Protocol::Vector2Info* newpos);
  private:
  const ::Protocol::Vector2Info& _internal_newpos() const;
  ::Protocol::Vector2Info* _internal_mutable_newpos();
  public:
  void unsafe_arena_set_allocated_newpos(
      ::Protocol::Vector2Info* newpos);
  ::Protocol::Vector2Info* unsafe_arena_release_newpos();

  // int32 playerId = 1;
  void clear_playerid();
  int32_t playerid() const;
  void set_playerid(int32_t value);
  private:
  int32_t _internal_playerid() const;
  void _internal_set_playerid(int32_t value);
  public:

  // .Protocol.EDirection direction = 2;
  void clear_direction();
  ::Protocol::EDirection direction() const;
  void set_direction(::Protocol::EDirection value);
  private:
  ::Protocol::EDirection _internal_direction() const;
  void _internal_set_direction(::Protocol::EDirection value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.PlayerMoveInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::Vector2Info* newpos_;
    int32_t playerid_;
    int direction_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class CharacterSummaryInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.CharacterSummaryInfo) */ {
 public:
  inline CharacterSummaryInfo() : CharacterSummaryInfo(nullptr) {}
  ~CharacterSummaryInfo() override;
  explicit PROTOBUF_CONSTEXPR CharacterSummaryInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CharacterSummaryInfo(const CharacterSummaryInfo& from);
  CharacterSummaryInfo(CharacterSummaryInfo&& from) noexcept
    : CharacterSummaryInfo() {
    *this = ::std::move(from);
  }

  inline CharacterSummaryInfo& operator=(const CharacterSummaryInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CharacterSummaryInfo& operator=(CharacterSummaryInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CharacterSummaryInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CharacterSummaryInfo* internal_default_instance() {
    return reinterpret_cast<const CharacterSummaryInfo*>(
               &_CharacterSummaryInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(CharacterSummaryInfo& a, CharacterSummaryInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CharacterSummaryInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CharacterSummaryInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CharacterSummaryInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CharacterSummaryInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CharacterSummaryInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CharacterSummaryInfo& from) {
    CharacterSummaryInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CharacterSummaryInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.CharacterSummaryInfo";
  }
  protected:
  explicit CharacterSummaryInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kLevelFieldNumber = 2,
    kGenderFieldNumber = 3,
    kRegionFieldNumber = 4,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // int32 level = 2;
  void clear_level();
  int32_t level() const;
  void set_level(int32_t value);
  private:
  int32_t _internal_level() const;
  void _internal_set_level(int32_t value);
  public:

  // .Protocol.EGender gender = 3;
  void clear_gender();
  ::Protocol::EGender gender() const;
  void set_gender(::Protocol::EGender value);
  private:
  ::Protocol::EGender _internal_gender() const;
  void _internal_set_gender(::Protocol::EGender value);
  public:

  // .Protocol.ERegion region = 4;
  void clear_region();
  ::Protocol::ERegion region() const;
  void set_region(::Protocol::ERegion value);
  private:
  ::Protocol::ERegion _internal_region() const;
  void _internal_set_region(::Protocol::ERegion value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.CharacterSummaryInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    int32_t level_;
    int gender_;
    int region_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class PlayerInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.PlayerInfo) */ {
 public:
  inline PlayerInfo() : PlayerInfo(nullptr) {}
  ~PlayerInfo() override;
  explicit PROTOBUF_CONSTEXPR PlayerInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerInfo(const PlayerInfo& from);
  PlayerInfo(PlayerInfo&& from) noexcept
    : PlayerInfo() {
    *this = ::std::move(from);
  }

  inline PlayerInfo& operator=(const PlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerInfo& operator=(PlayerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerInfo* internal_default_instance() {
    return reinterpret_cast<const PlayerInfo*>(
               &_PlayerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(PlayerInfo& a, PlayerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlayerInfo& from) {
    PlayerInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.PlayerInfo";
  }
  protected:
  explicit PlayerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 2,
    kPosFieldNumber = 3,
    kIdFieldNumber = 1,
    kDirectionFieldNumber = 4,
  };
  // string username = 2;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // .Protocol.Vector2Info pos = 3;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::Protocol::Vector2Info& pos() const;
  PROTOBUF_NODISCARD ::Protocol::Vector2Info* release_pos();
  ::Protocol::Vector2Info* mutable_pos();
  void set_allocated_pos(::Protocol::Vector2Info* pos);
  private:
  const ::Protocol::Vector2Info& _internal_pos() const;
  ::Protocol::Vector2Info* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::Protocol::Vector2Info* pos);
  ::Protocol::Vector2Info* unsafe_arena_release_pos();

  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // .Protocol.EDirection direction = 4;
  void clear_direction();
  ::Protocol::EDirection direction() const;
  void set_direction(::Protocol::EDirection value);
  private:
  ::Protocol::EDirection _internal_direction() const;
  void _internal_set_direction(::Protocol::EDirection value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.PlayerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::Protocol::Vector2Info* pos_;
    int32_t id_;
    int direction_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// C_JwtLoginRequest

// string accessToken = 1;
inline void C_JwtLoginRequest::clear_accesstoken() {
  _impl_.accesstoken_.ClearToEmpty();
}
inline const std::string& C_JwtLoginRequest::accesstoken() const {
  // @@protoc_insertion_point(field_get:Protocol.C_JwtLoginRequest.accessToken)
  return _internal_accesstoken();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_JwtLoginRequest::set_accesstoken(ArgT0&& arg0, ArgT... args) {
 
 _impl_.accesstoken_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_JwtLoginRequest.accessToken)
}
inline std::string* C_JwtLoginRequest::mutable_accesstoken() {
  std::string* _s = _internal_mutable_accesstoken();
  // @@protoc_insertion_point(field_mutable:Protocol.C_JwtLoginRequest.accessToken)
  return _s;
}
inline const std::string& C_JwtLoginRequest::_internal_accesstoken() const {
  return _impl_.accesstoken_.Get();
}
inline void C_JwtLoginRequest::_internal_set_accesstoken(const std::string& value) {
  
  _impl_.accesstoken_.Set(value, GetArenaForAllocation());
}
inline std::string* C_JwtLoginRequest::_internal_mutable_accesstoken() {
  
  return _impl_.accesstoken_.Mutable(GetArenaForAllocation());
}
inline std::string* C_JwtLoginRequest::release_accesstoken() {
  // @@protoc_insertion_point(field_release:Protocol.C_JwtLoginRequest.accessToken)
  return _impl_.accesstoken_.Release();
}
inline void C_JwtLoginRequest::set_allocated_accesstoken(std::string* accesstoken) {
  if (accesstoken != nullptr) {
    
  } else {
    
  }
  _impl_.accesstoken_.SetAllocated(accesstoken, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.accesstoken_.IsDefault()) {
    _impl_.accesstoken_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_JwtLoginRequest.accessToken)
}

// -------------------------------------------------------------------

// S_JwtLoginReply

// .Protocol.ELoginResult result = 1;
inline void S_JwtLoginReply::clear_result() {
  _impl_.result_ = 0;
}
inline ::Protocol::ELoginResult S_JwtLoginReply::_internal_result() const {
  return static_cast< ::Protocol::ELoginResult >(_impl_.result_);
}
inline ::Protocol::ELoginResult S_JwtLoginReply::result() const {
  // @@protoc_insertion_point(field_get:Protocol.S_JwtLoginReply.result)
  return _internal_result();
}
inline void S_JwtLoginReply::_internal_set_result(::Protocol::ELoginResult value) {
  
  _impl_.result_ = value;
}
inline void S_JwtLoginReply::set_result(::Protocol::ELoginResult value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:Protocol.S_JwtLoginReply.result)
}

// -------------------------------------------------------------------

// C_CreateCharacterRequest

// string username = 1;
inline void C_CreateCharacterRequest::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& C_CreateCharacterRequest::username() const {
  // @@protoc_insertion_point(field_get:Protocol.C_CreateCharacterRequest.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_CreateCharacterRequest::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_CreateCharacterRequest.username)
}
inline std::string* C_CreateCharacterRequest::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:Protocol.C_CreateCharacterRequest.username)
  return _s;
}
inline const std::string& C_CreateCharacterRequest::_internal_username() const {
  return _impl_.username_.Get();
}
inline void C_CreateCharacterRequest::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* C_CreateCharacterRequest::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* C_CreateCharacterRequest::release_username() {
  // @@protoc_insertion_point(field_release:Protocol.C_CreateCharacterRequest.username)
  return _impl_.username_.Release();
}
inline void C_CreateCharacterRequest::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_CreateCharacterRequest.username)
}

// .Protocol.EGender gender = 2;
inline void C_CreateCharacterRequest::clear_gender() {
  _impl_.gender_ = 0;
}
inline ::Protocol::EGender C_CreateCharacterRequest::_internal_gender() const {
  return static_cast< ::Protocol::EGender >(_impl_.gender_);
}
inline ::Protocol::EGender C_CreateCharacterRequest::gender() const {
  // @@protoc_insertion_point(field_get:Protocol.C_CreateCharacterRequest.gender)
  return _internal_gender();
}
inline void C_CreateCharacterRequest::_internal_set_gender(::Protocol::EGender value) {
  
  _impl_.gender_ = value;
}
inline void C_CreateCharacterRequest::set_gender(::Protocol::EGender value) {
  _internal_set_gender(value);
  // @@protoc_insertion_point(field_set:Protocol.C_CreateCharacterRequest.gender)
}

// .Protocol.ERegion region = 3;
inline void C_CreateCharacterRequest::clear_region() {
  _impl_.region_ = 0;
}
inline ::Protocol::ERegion C_CreateCharacterRequest::_internal_region() const {
  return static_cast< ::Protocol::ERegion >(_impl_.region_);
}
inline ::Protocol::ERegion C_CreateCharacterRequest::region() const {
  // @@protoc_insertion_point(field_get:Protocol.C_CreateCharacterRequest.region)
  return _internal_region();
}
inline void C_CreateCharacterRequest::_internal_set_region(::Protocol::ERegion value) {
  
  _impl_.region_ = value;
}
inline void C_CreateCharacterRequest::set_region(::Protocol::ERegion value) {
  _internal_set_region(value);
  // @@protoc_insertion_point(field_set:Protocol.C_CreateCharacterRequest.region)
}

// -------------------------------------------------------------------

// S_CreateCharacterReply

// bool success = 1;
inline void S_CreateCharacterReply::clear_success() {
  _impl_.success_ = false;
}
inline bool S_CreateCharacterReply::_internal_success() const {
  return _impl_.success_;
}
inline bool S_CreateCharacterReply::success() const {
  // @@protoc_insertion_point(field_get:Protocol.S_CreateCharacterReply.success)
  return _internal_success();
}
inline void S_CreateCharacterReply::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void S_CreateCharacterReply::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.S_CreateCharacterReply.success)
}

// string detail = 2;
inline void S_CreateCharacterReply::clear_detail() {
  _impl_.detail_.ClearToEmpty();
}
inline const std::string& S_CreateCharacterReply::detail() const {
  // @@protoc_insertion_point(field_get:Protocol.S_CreateCharacterReply.detail)
  return _internal_detail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_CreateCharacterReply::set_detail(ArgT0&& arg0, ArgT... args) {
 
 _impl_.detail_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_CreateCharacterReply.detail)
}
inline std::string* S_CreateCharacterReply::mutable_detail() {
  std::string* _s = _internal_mutable_detail();
  // @@protoc_insertion_point(field_mutable:Protocol.S_CreateCharacterReply.detail)
  return _s;
}
inline const std::string& S_CreateCharacterReply::_internal_detail() const {
  return _impl_.detail_.Get();
}
inline void S_CreateCharacterReply::_internal_set_detail(const std::string& value) {
  
  _impl_.detail_.Set(value, GetArenaForAllocation());
}
inline std::string* S_CreateCharacterReply::_internal_mutable_detail() {
  
  return _impl_.detail_.Mutable(GetArenaForAllocation());
}
inline std::string* S_CreateCharacterReply::release_detail() {
  // @@protoc_insertion_point(field_release:Protocol.S_CreateCharacterReply.detail)
  return _impl_.detail_.Release();
}
inline void S_CreateCharacterReply::set_allocated_detail(std::string* detail) {
  if (detail != nullptr) {
    
  } else {
    
  }
  _impl_.detail_.SetAllocated(detail, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.detail_.IsDefault()) {
    _impl_.detail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_CreateCharacterReply.detail)
}

// -------------------------------------------------------------------

// C_CharacterListRequest

// -------------------------------------------------------------------

// S_CharacterListReply

// repeated .Protocol.CharacterSummaryInfo characters = 1;
inline int S_CharacterListReply::_internal_characters_size() const {
  return _impl_.characters_.size();
}
inline int S_CharacterListReply::characters_size() const {
  return _internal_characters_size();
}
inline void S_CharacterListReply::clear_characters() {
  _impl_.characters_.Clear();
}
inline ::Protocol::CharacterSummaryInfo* S_CharacterListReply::mutable_characters(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_CharacterListReply.characters)
  return _impl_.characters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::CharacterSummaryInfo >*
S_CharacterListReply::mutable_characters() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_CharacterListReply.characters)
  return &_impl_.characters_;
}
inline const ::Protocol::CharacterSummaryInfo& S_CharacterListReply::_internal_characters(int index) const {
  return _impl_.characters_.Get(index);
}
inline const ::Protocol::CharacterSummaryInfo& S_CharacterListReply::characters(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_CharacterListReply.characters)
  return _internal_characters(index);
}
inline ::Protocol::CharacterSummaryInfo* S_CharacterListReply::_internal_add_characters() {
  return _impl_.characters_.Add();
}
inline ::Protocol::CharacterSummaryInfo* S_CharacterListReply::add_characters() {
  ::Protocol::CharacterSummaryInfo* _add = _internal_add_characters();
  // @@protoc_insertion_point(field_add:Protocol.S_CharacterListReply.characters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::CharacterSummaryInfo >&
S_CharacterListReply::characters() const {
  // @@protoc_insertion_point(field_list:Protocol.S_CharacterListReply.characters)
  return _impl_.characters_;
}

// -------------------------------------------------------------------

// C_EnterGame

// int32 playerIndex = 1;
inline void C_EnterGame::clear_playerindex() {
  _impl_.playerindex_ = 0;
}
inline int32_t C_EnterGame::_internal_playerindex() const {
  return _impl_.playerindex_;
}
inline int32_t C_EnterGame::playerindex() const {
  // @@protoc_insertion_point(field_get:Protocol.C_EnterGame.playerIndex)
  return _internal_playerindex();
}
inline void C_EnterGame::_internal_set_playerindex(int32_t value) {
  
  _impl_.playerindex_ = value;
}
inline void C_EnterGame::set_playerindex(int32_t value) {
  _internal_set_playerindex(value);
  // @@protoc_insertion_point(field_set:Protocol.C_EnterGame.playerIndex)
}

// -------------------------------------------------------------------

// S_EnterGame

// int32 success = 1;
inline void S_EnterGame::clear_success() {
  _impl_.success_ = 0;
}
inline int32_t S_EnterGame::_internal_success() const {
  return _impl_.success_;
}
inline int32_t S_EnterGame::success() const {
  // @@protoc_insertion_point(field_get:Protocol.S_EnterGame.success)
  return _internal_success();
}
inline void S_EnterGame::_internal_set_success(int32_t value) {
  
  _impl_.success_ = value;
}
inline void S_EnterGame::set_success(int32_t value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.S_EnterGame.success)
}

// -------------------------------------------------------------------

// S_PlayerList

// int32 myPlayerId = 1;
inline void S_PlayerList::clear_myplayerid() {
  _impl_.myplayerid_ = 0;
}
inline int32_t S_PlayerList::_internal_myplayerid() const {
  return _impl_.myplayerid_;
}
inline int32_t S_PlayerList::myplayerid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_PlayerList.myPlayerId)
  return _internal_myplayerid();
}
inline void S_PlayerList::_internal_set_myplayerid(int32_t value) {
  
  _impl_.myplayerid_ = value;
}
inline void S_PlayerList::set_myplayerid(int32_t value) {
  _internal_set_myplayerid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_PlayerList.myPlayerId)
}

// repeated .Protocol.PlayerInfo players = 2;
inline int S_PlayerList::_internal_players_size() const {
  return _impl_.players_.size();
}
inline int S_PlayerList::players_size() const {
  return _internal_players_size();
}
inline void S_PlayerList::clear_players() {
  _impl_.players_.Clear();
}
inline ::Protocol::PlayerInfo* S_PlayerList::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_PlayerList.players)
  return _impl_.players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerInfo >*
S_PlayerList::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_PlayerList.players)
  return &_impl_.players_;
}
inline const ::Protocol::PlayerInfo& S_PlayerList::_internal_players(int index) const {
  return _impl_.players_.Get(index);
}
inline const ::Protocol::PlayerInfo& S_PlayerList::players(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_PlayerList.players)
  return _internal_players(index);
}
inline ::Protocol::PlayerInfo* S_PlayerList::_internal_add_players() {
  return _impl_.players_.Add();
}
inline ::Protocol::PlayerInfo* S_PlayerList::add_players() {
  ::Protocol::PlayerInfo* _add = _internal_add_players();
  // @@protoc_insertion_point(field_add:Protocol.S_PlayerList.players)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerInfo >&
S_PlayerList::players() const {
  // @@protoc_insertion_point(field_list:Protocol.S_PlayerList.players)
  return _impl_.players_;
}

// -------------------------------------------------------------------

// S_BroadcastPlayerEnter

// .Protocol.PlayerInfo player = 1;
inline bool S_BroadcastPlayerEnter::_internal_has_player() const {
  return this != internal_default_instance() && _impl_.player_ != nullptr;
}
inline bool S_BroadcastPlayerEnter::has_player() const {
  return _internal_has_player();
}
inline void S_BroadcastPlayerEnter::clear_player() {
  if (GetArenaForAllocation() == nullptr && _impl_.player_ != nullptr) {
    delete _impl_.player_;
  }
  _impl_.player_ = nullptr;
}
inline const ::Protocol::PlayerInfo& S_BroadcastPlayerEnter::_internal_player() const {
  const ::Protocol::PlayerInfo* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PlayerInfo&>(
      ::Protocol::_PlayerInfo_default_instance_);
}
inline const ::Protocol::PlayerInfo& S_BroadcastPlayerEnter::player() const {
  // @@protoc_insertion_point(field_get:Protocol.S_BroadcastPlayerEnter.player)
  return _internal_player();
}
inline void S_BroadcastPlayerEnter::unsafe_arena_set_allocated_player(
    ::Protocol::PlayerInfo* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_BroadcastPlayerEnter.player)
}
inline ::Protocol::PlayerInfo* S_BroadcastPlayerEnter::release_player() {
  
  ::Protocol::PlayerInfo* temp = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::PlayerInfo* S_BroadcastPlayerEnter::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:Protocol.S_BroadcastPlayerEnter.player)
  
  ::Protocol::PlayerInfo* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::Protocol::PlayerInfo* S_BroadcastPlayerEnter::_internal_mutable_player() {
  
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PlayerInfo>(GetArenaForAllocation());
    _impl_.player_ = p;
  }
  return _impl_.player_;
}
inline ::Protocol::PlayerInfo* S_BroadcastPlayerEnter::mutable_player() {
  ::Protocol::PlayerInfo* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:Protocol.S_BroadcastPlayerEnter.player)
  return _msg;
}
inline void S_BroadcastPlayerEnter::set_allocated_player(::Protocol::PlayerInfo* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.player_;
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(player);
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.player_ = player;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_BroadcastPlayerEnter.player)
}

// -------------------------------------------------------------------

// C_LeaveGame

// .Protocol.ELeaveReason reason = 1;
inline void C_LeaveGame::clear_reason() {
  _impl_.reason_ = 0;
}
inline ::Protocol::ELeaveReason C_LeaveGame::_internal_reason() const {
  return static_cast< ::Protocol::ELeaveReason >(_impl_.reason_);
}
inline ::Protocol::ELeaveReason C_LeaveGame::reason() const {
  // @@protoc_insertion_point(field_get:Protocol.C_LeaveGame.reason)
  return _internal_reason();
}
inline void C_LeaveGame::_internal_set_reason(::Protocol::ELeaveReason value) {
  
  _impl_.reason_ = value;
}
inline void C_LeaveGame::set_reason(::Protocol::ELeaveReason value) {
  _internal_set_reason(value);
  // @@protoc_insertion_point(field_set:Protocol.C_LeaveGame.reason)
}

// -------------------------------------------------------------------

// S_LeaveGame

// int32 success = 1;
inline void S_LeaveGame::clear_success() {
  _impl_.success_ = 0;
}
inline int32_t S_LeaveGame::_internal_success() const {
  return _impl_.success_;
}
inline int32_t S_LeaveGame::success() const {
  // @@protoc_insertion_point(field_get:Protocol.S_LeaveGame.success)
  return _internal_success();
}
inline void S_LeaveGame::_internal_set_success(int32_t value) {
  
  _impl_.success_ = value;
}
inline void S_LeaveGame::set_success(int32_t value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.S_LeaveGame.success)
}

// -------------------------------------------------------------------

// S_BroadcastPlayerLeave

// int32 playerId = 1;
inline void S_BroadcastPlayerLeave::clear_playerid() {
  _impl_.playerid_ = 0;
}
inline int32_t S_BroadcastPlayerLeave::_internal_playerid() const {
  return _impl_.playerid_;
}
inline int32_t S_BroadcastPlayerLeave::playerid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_BroadcastPlayerLeave.playerId)
  return _internal_playerid();
}
inline void S_BroadcastPlayerLeave::_internal_set_playerid(int32_t value) {
  
  _impl_.playerid_ = value;
}
inline void S_BroadcastPlayerLeave::set_playerid(int32_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_BroadcastPlayerLeave.playerId)
}

// .Protocol.ELeaveReason reason = 2;
inline void S_BroadcastPlayerLeave::clear_reason() {
  _impl_.reason_ = 0;
}
inline ::Protocol::ELeaveReason S_BroadcastPlayerLeave::_internal_reason() const {
  return static_cast< ::Protocol::ELeaveReason >(_impl_.reason_);
}
inline ::Protocol::ELeaveReason S_BroadcastPlayerLeave::reason() const {
  // @@protoc_insertion_point(field_get:Protocol.S_BroadcastPlayerLeave.reason)
  return _internal_reason();
}
inline void S_BroadcastPlayerLeave::_internal_set_reason(::Protocol::ELeaveReason value) {
  
  _impl_.reason_ = value;
}
inline void S_BroadcastPlayerLeave::set_reason(::Protocol::ELeaveReason value) {
  _internal_set_reason(value);
  // @@protoc_insertion_point(field_set:Protocol.S_BroadcastPlayerLeave.reason)
}

// -------------------------------------------------------------------

// C_PlayerMoveRequest

// .Protocol.Vector2Info clickWorldPos = 1;
inline bool C_PlayerMoveRequest::_internal_has_clickworldpos() const {
  return this != internal_default_instance() && _impl_.clickworldpos_ != nullptr;
}
inline bool C_PlayerMoveRequest::has_clickworldpos() const {
  return _internal_has_clickworldpos();
}
inline void C_PlayerMoveRequest::clear_clickworldpos() {
  if (GetArenaForAllocation() == nullptr && _impl_.clickworldpos_ != nullptr) {
    delete _impl_.clickworldpos_;
  }
  _impl_.clickworldpos_ = nullptr;
}
inline const ::Protocol::Vector2Info& C_PlayerMoveRequest::_internal_clickworldpos() const {
  const ::Protocol::Vector2Info* p = _impl_.clickworldpos_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::Vector2Info&>(
      ::Protocol::_Vector2Info_default_instance_);
}
inline const ::Protocol::Vector2Info& C_PlayerMoveRequest::clickworldpos() const {
  // @@protoc_insertion_point(field_get:Protocol.C_PlayerMoveRequest.clickWorldPos)
  return _internal_clickworldpos();
}
inline void C_PlayerMoveRequest::unsafe_arena_set_allocated_clickworldpos(
    ::Protocol::Vector2Info* clickworldpos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.clickworldpos_);
  }
  _impl_.clickworldpos_ = clickworldpos;
  if (clickworldpos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.C_PlayerMoveRequest.clickWorldPos)
}
inline ::Protocol::Vector2Info* C_PlayerMoveRequest::release_clickworldpos() {
  
  ::Protocol::Vector2Info* temp = _impl_.clickworldpos_;
  _impl_.clickworldpos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::Vector2Info* C_PlayerMoveRequest::unsafe_arena_release_clickworldpos() {
  // @@protoc_insertion_point(field_release:Protocol.C_PlayerMoveRequest.clickWorldPos)
  
  ::Protocol::Vector2Info* temp = _impl_.clickworldpos_;
  _impl_.clickworldpos_ = nullptr;
  return temp;
}
inline ::Protocol::Vector2Info* C_PlayerMoveRequest::_internal_mutable_clickworldpos() {
  
  if (_impl_.clickworldpos_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::Vector2Info>(GetArenaForAllocation());
    _impl_.clickworldpos_ = p;
  }
  return _impl_.clickworldpos_;
}
inline ::Protocol::Vector2Info* C_PlayerMoveRequest::mutable_clickworldpos() {
  ::Protocol::Vector2Info* _msg = _internal_mutable_clickworldpos();
  // @@protoc_insertion_point(field_mutable:Protocol.C_PlayerMoveRequest.clickWorldPos)
  return _msg;
}
inline void C_PlayerMoveRequest::set_allocated_clickworldpos(::Protocol::Vector2Info* clickworldpos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.clickworldpos_;
  }
  if (clickworldpos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(clickworldpos);
    if (message_arena != submessage_arena) {
      clickworldpos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, clickworldpos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.clickworldpos_ = clickworldpos;
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_PlayerMoveRequest.clickWorldPos)
}

// -------------------------------------------------------------------

// S_PlayerMoveReply

// int32 playerId = 1;
inline void S_PlayerMoveReply::clear_playerid() {
  _impl_.playerid_ = 0;
}
inline int32_t S_PlayerMoveReply::_internal_playerid() const {
  return _impl_.playerid_;
}
inline int32_t S_PlayerMoveReply::playerid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_PlayerMoveReply.playerId)
  return _internal_playerid();
}
inline void S_PlayerMoveReply::_internal_set_playerid(int32_t value) {
  
  _impl_.playerid_ = value;
}
inline void S_PlayerMoveReply::set_playerid(int32_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_PlayerMoveReply.playerId)
}

// int32 clientSeq = 2;
inline void S_PlayerMoveReply::clear_clientseq() {
  _impl_.clientseq_ = 0;
}
inline int32_t S_PlayerMoveReply::_internal_clientseq() const {
  return _impl_.clientseq_;
}
inline int32_t S_PlayerMoveReply::clientseq() const {
  // @@protoc_insertion_point(field_get:Protocol.S_PlayerMoveReply.clientSeq)
  return _internal_clientseq();
}
inline void S_PlayerMoveReply::_internal_set_clientseq(int32_t value) {
  
  _impl_.clientseq_ = value;
}
inline void S_PlayerMoveReply::set_clientseq(int32_t value) {
  _internal_set_clientseq(value);
  // @@protoc_insertion_point(field_set:Protocol.S_PlayerMoveReply.clientSeq)
}

// .Protocol.EMoveResult result = 3;
inline void S_PlayerMoveReply::clear_result() {
  _impl_.result_ = 0;
}
inline ::Protocol::EMoveResult S_PlayerMoveReply::_internal_result() const {
  return static_cast< ::Protocol::EMoveResult >(_impl_.result_);
}
inline ::Protocol::EMoveResult S_PlayerMoveReply::result() const {
  // @@protoc_insertion_point(field_get:Protocol.S_PlayerMoveReply.result)
  return _internal_result();
}
inline void S_PlayerMoveReply::_internal_set_result(::Protocol::EMoveResult value) {
  
  _impl_.result_ = value;
}
inline void S_PlayerMoveReply::set_result(::Protocol::EMoveResult value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:Protocol.S_PlayerMoveReply.result)
}

// int32 tick = 4;
inline void S_PlayerMoveReply::clear_tick() {
  _impl_.tick_ = 0;
}
inline int32_t S_PlayerMoveReply::_internal_tick() const {
  return _impl_.tick_;
}
inline int32_t S_PlayerMoveReply::tick() const {
  // @@protoc_insertion_point(field_get:Protocol.S_PlayerMoveReply.tick)
  return _internal_tick();
}
inline void S_PlayerMoveReply::_internal_set_tick(int32_t value) {
  
  _impl_.tick_ = value;
}
inline void S_PlayerMoveReply::set_tick(int32_t value) {
  _internal_set_tick(value);
  // @@protoc_insertion_point(field_set:Protocol.S_PlayerMoveReply.tick)
}

// .Protocol.Vector2Info newPos = 5;
inline bool S_PlayerMoveReply::_internal_has_newpos() const {
  return this != internal_default_instance() && _impl_.newpos_ != nullptr;
}
inline bool S_PlayerMoveReply::has_newpos() const {
  return _internal_has_newpos();
}
inline void S_PlayerMoveReply::clear_newpos() {
  if (GetArenaForAllocation() == nullptr && _impl_.newpos_ != nullptr) {
    delete _impl_.newpos_;
  }
  _impl_.newpos_ = nullptr;
}
inline const ::Protocol::Vector2Info& S_PlayerMoveReply::_internal_newpos() const {
  const ::Protocol::Vector2Info* p = _impl_.newpos_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::Vector2Info&>(
      ::Protocol::_Vector2Info_default_instance_);
}
inline const ::Protocol::Vector2Info& S_PlayerMoveReply::newpos() const {
  // @@protoc_insertion_point(field_get:Protocol.S_PlayerMoveReply.newPos)
  return _internal_newpos();
}
inline void S_PlayerMoveReply::unsafe_arena_set_allocated_newpos(
    ::Protocol::Vector2Info* newpos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.newpos_);
  }
  _impl_.newpos_ = newpos;
  if (newpos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_PlayerMoveReply.newPos)
}
inline ::Protocol::Vector2Info* S_PlayerMoveReply::release_newpos() {
  
  ::Protocol::Vector2Info* temp = _impl_.newpos_;
  _impl_.newpos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::Vector2Info* S_PlayerMoveReply::unsafe_arena_release_newpos() {
  // @@protoc_insertion_point(field_release:Protocol.S_PlayerMoveReply.newPos)
  
  ::Protocol::Vector2Info* temp = _impl_.newpos_;
  _impl_.newpos_ = nullptr;
  return temp;
}
inline ::Protocol::Vector2Info* S_PlayerMoveReply::_internal_mutable_newpos() {
  
  if (_impl_.newpos_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::Vector2Info>(GetArenaForAllocation());
    _impl_.newpos_ = p;
  }
  return _impl_.newpos_;
}
inline ::Protocol::Vector2Info* S_PlayerMoveReply::mutable_newpos() {
  ::Protocol::Vector2Info* _msg = _internal_mutable_newpos();
  // @@protoc_insertion_point(field_mutable:Protocol.S_PlayerMoveReply.newPos)
  return _msg;
}
inline void S_PlayerMoveReply::set_allocated_newpos(::Protocol::Vector2Info* newpos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.newpos_;
  }
  if (newpos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(newpos);
    if (message_arena != submessage_arena) {
      newpos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, newpos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.newpos_ = newpos;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_PlayerMoveReply.newPos)
}

// .Protocol.EDirection direction = 6;
inline void S_PlayerMoveReply::clear_direction() {
  _impl_.direction_ = 0;
}
inline ::Protocol::EDirection S_PlayerMoveReply::_internal_direction() const {
  return static_cast< ::Protocol::EDirection >(_impl_.direction_);
}
inline ::Protocol::EDirection S_PlayerMoveReply::direction() const {
  // @@protoc_insertion_point(field_get:Protocol.S_PlayerMoveReply.direction)
  return _internal_direction();
}
inline void S_PlayerMoveReply::_internal_set_direction(::Protocol::EDirection value) {
  
  _impl_.direction_ = value;
}
inline void S_PlayerMoveReply::set_direction(::Protocol::EDirection value) {
  _internal_set_direction(value);
  // @@protoc_insertion_point(field_set:Protocol.S_PlayerMoveReply.direction)
}

// -------------------------------------------------------------------

// S_BroadcastPlayerMove

// int32 tick = 1;
inline void S_BroadcastPlayerMove::clear_tick() {
  _impl_.tick_ = 0;
}
inline int32_t S_BroadcastPlayerMove::_internal_tick() const {
  return _impl_.tick_;
}
inline int32_t S_BroadcastPlayerMove::tick() const {
  // @@protoc_insertion_point(field_get:Protocol.S_BroadcastPlayerMove.tick)
  return _internal_tick();
}
inline void S_BroadcastPlayerMove::_internal_set_tick(int32_t value) {
  
  _impl_.tick_ = value;
}
inline void S_BroadcastPlayerMove::set_tick(int32_t value) {
  _internal_set_tick(value);
  // @@protoc_insertion_point(field_set:Protocol.S_BroadcastPlayerMove.tick)
}

// repeated .Protocol.PlayerMoveInfo playerMoves = 2;
inline int S_BroadcastPlayerMove::_internal_playermoves_size() const {
  return _impl_.playermoves_.size();
}
inline int S_BroadcastPlayerMove::playermoves_size() const {
  return _internal_playermoves_size();
}
inline void S_BroadcastPlayerMove::clear_playermoves() {
  _impl_.playermoves_.Clear();
}
inline ::Protocol::PlayerMoveInfo* S_BroadcastPlayerMove::mutable_playermoves(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_BroadcastPlayerMove.playerMoves)
  return _impl_.playermoves_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerMoveInfo >*
S_BroadcastPlayerMove::mutable_playermoves() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_BroadcastPlayerMove.playerMoves)
  return &_impl_.playermoves_;
}
inline const ::Protocol::PlayerMoveInfo& S_BroadcastPlayerMove::_internal_playermoves(int index) const {
  return _impl_.playermoves_.Get(index);
}
inline const ::Protocol::PlayerMoveInfo& S_BroadcastPlayerMove::playermoves(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_BroadcastPlayerMove.playerMoves)
  return _internal_playermoves(index);
}
inline ::Protocol::PlayerMoveInfo* S_BroadcastPlayerMove::_internal_add_playermoves() {
  return _impl_.playermoves_.Add();
}
inline ::Protocol::PlayerMoveInfo* S_BroadcastPlayerMove::add_playermoves() {
  ::Protocol::PlayerMoveInfo* _add = _internal_add_playermoves();
  // @@protoc_insertion_point(field_add:Protocol.S_BroadcastPlayerMove.playerMoves)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerMoveInfo >&
S_BroadcastPlayerMove::playermoves() const {
  // @@protoc_insertion_point(field_list:Protocol.S_BroadcastPlayerMove.playerMoves)
  return _impl_.playermoves_;
}

// -------------------------------------------------------------------

// S_ChangeRoomBegin

// int32 transitionId = 1;
inline void S_ChangeRoomBegin::clear_transitionid() {
  _impl_.transitionid_ = 0;
}
inline int32_t S_ChangeRoomBegin::_internal_transitionid() const {
  return _impl_.transitionid_;
}
inline int32_t S_ChangeRoomBegin::transitionid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ChangeRoomBegin.transitionId)
  return _internal_transitionid();
}
inline void S_ChangeRoomBegin::_internal_set_transitionid(int32_t value) {
  
  _impl_.transitionid_ = value;
}
inline void S_ChangeRoomBegin::set_transitionid(int32_t value) {
  _internal_set_transitionid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_ChangeRoomBegin.transitionId)
}

// int32 mapId = 2;
inline void S_ChangeRoomBegin::clear_mapid() {
  _impl_.mapid_ = 0;
}
inline int32_t S_ChangeRoomBegin::_internal_mapid() const {
  return _impl_.mapid_;
}
inline int32_t S_ChangeRoomBegin::mapid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ChangeRoomBegin.mapId)
  return _internal_mapid();
}
inline void S_ChangeRoomBegin::_internal_set_mapid(int32_t value) {
  
  _impl_.mapid_ = value;
}
inline void S_ChangeRoomBegin::set_mapid(int32_t value) {
  _internal_set_mapid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_ChangeRoomBegin.mapId)
}

// -------------------------------------------------------------------

// C_ChangeRoomReady

// int32 transitionId = 1;
inline void C_ChangeRoomReady::clear_transitionid() {
  _impl_.transitionid_ = 0;
}
inline int32_t C_ChangeRoomReady::_internal_transitionid() const {
  return _impl_.transitionid_;
}
inline int32_t C_ChangeRoomReady::transitionid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_ChangeRoomReady.transitionId)
  return _internal_transitionid();
}
inline void C_ChangeRoomReady::_internal_set_transitionid(int32_t value) {
  
  _impl_.transitionid_ = value;
}
inline void C_ChangeRoomReady::set_transitionid(int32_t value) {
  _internal_set_transitionid(value);
  // @@protoc_insertion_point(field_set:Protocol.C_ChangeRoomReady.transitionId)
}

// -------------------------------------------------------------------

// S_ChangeRoomCommit

// int32 transitionId = 1;
inline void S_ChangeRoomCommit::clear_transitionid() {
  _impl_.transitionid_ = 0;
}
inline int32_t S_ChangeRoomCommit::_internal_transitionid() const {
  return _impl_.transitionid_;
}
inline int32_t S_ChangeRoomCommit::transitionid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ChangeRoomCommit.transitionId)
  return _internal_transitionid();
}
inline void S_ChangeRoomCommit::_internal_set_transitionid(int32_t value) {
  
  _impl_.transitionid_ = value;
}
inline void S_ChangeRoomCommit::set_transitionid(int32_t value) {
  _internal_set_transitionid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_ChangeRoomCommit.transitionId)
}

// .Protocol.S_PlayerList snapshots = 2;
inline bool S_ChangeRoomCommit::_internal_has_snapshots() const {
  return this != internal_default_instance() && _impl_.snapshots_ != nullptr;
}
inline bool S_ChangeRoomCommit::has_snapshots() const {
  return _internal_has_snapshots();
}
inline void S_ChangeRoomCommit::clear_snapshots() {
  if (GetArenaForAllocation() == nullptr && _impl_.snapshots_ != nullptr) {
    delete _impl_.snapshots_;
  }
  _impl_.snapshots_ = nullptr;
}
inline const ::Protocol::S_PlayerList& S_ChangeRoomCommit::_internal_snapshots() const {
  const ::Protocol::S_PlayerList* p = _impl_.snapshots_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::S_PlayerList&>(
      ::Protocol::_S_PlayerList_default_instance_);
}
inline const ::Protocol::S_PlayerList& S_ChangeRoomCommit::snapshots() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ChangeRoomCommit.snapshots)
  return _internal_snapshots();
}
inline void S_ChangeRoomCommit::unsafe_arena_set_allocated_snapshots(
    ::Protocol::S_PlayerList* snapshots) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.snapshots_);
  }
  _impl_.snapshots_ = snapshots;
  if (snapshots) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_ChangeRoomCommit.snapshots)
}
inline ::Protocol::S_PlayerList* S_ChangeRoomCommit::release_snapshots() {
  
  ::Protocol::S_PlayerList* temp = _impl_.snapshots_;
  _impl_.snapshots_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::S_PlayerList* S_ChangeRoomCommit::unsafe_arena_release_snapshots() {
  // @@protoc_insertion_point(field_release:Protocol.S_ChangeRoomCommit.snapshots)
  
  ::Protocol::S_PlayerList* temp = _impl_.snapshots_;
  _impl_.snapshots_ = nullptr;
  return temp;
}
inline ::Protocol::S_PlayerList* S_ChangeRoomCommit::_internal_mutable_snapshots() {
  
  if (_impl_.snapshots_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::S_PlayerList>(GetArenaForAllocation());
    _impl_.snapshots_ = p;
  }
  return _impl_.snapshots_;
}
inline ::Protocol::S_PlayerList* S_ChangeRoomCommit::mutable_snapshots() {
  ::Protocol::S_PlayerList* _msg = _internal_mutable_snapshots();
  // @@protoc_insertion_point(field_mutable:Protocol.S_ChangeRoomCommit.snapshots)
  return _msg;
}
inline void S_ChangeRoomCommit::set_allocated_snapshots(::Protocol::S_PlayerList* snapshots) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.snapshots_;
  }
  if (snapshots) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(snapshots);
    if (message_arena != submessage_arena) {
      snapshots = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, snapshots, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.snapshots_ = snapshots;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_ChangeRoomCommit.snapshots)
}

// -------------------------------------------------------------------

// S_SpawnMonster

// int32 monsterId = 1;
inline void S_SpawnMonster::clear_monsterid() {
  _impl_.monsterid_ = 0;
}
inline int32_t S_SpawnMonster::_internal_monsterid() const {
  return _impl_.monsterid_;
}
inline int32_t S_SpawnMonster::monsterid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SpawnMonster.monsterId)
  return _internal_monsterid();
}
inline void S_SpawnMonster::_internal_set_monsterid(int32_t value) {
  
  _impl_.monsterid_ = value;
}
inline void S_SpawnMonster::set_monsterid(int32_t value) {
  _internal_set_monsterid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_SpawnMonster.monsterId)
}

// int32 monsterTypeId = 2;
inline void S_SpawnMonster::clear_monstertypeid() {
  _impl_.monstertypeid_ = 0;
}
inline int32_t S_SpawnMonster::_internal_monstertypeid() const {
  return _impl_.monstertypeid_;
}
inline int32_t S_SpawnMonster::monstertypeid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SpawnMonster.monsterTypeId)
  return _internal_monstertypeid();
}
inline void S_SpawnMonster::_internal_set_monstertypeid(int32_t value) {
  
  _impl_.monstertypeid_ = value;
}
inline void S_SpawnMonster::set_monstertypeid(int32_t value) {
  _internal_set_monstertypeid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_SpawnMonster.monsterTypeId)
}

// int32 x = 3;
inline void S_SpawnMonster::clear_x() {
  _impl_.x_ = 0;
}
inline int32_t S_SpawnMonster::_internal_x() const {
  return _impl_.x_;
}
inline int32_t S_SpawnMonster::x() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SpawnMonster.x)
  return _internal_x();
}
inline void S_SpawnMonster::_internal_set_x(int32_t value) {
  
  _impl_.x_ = value;
}
inline void S_SpawnMonster::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Protocol.S_SpawnMonster.x)
}

// int32 y = 4;
inline void S_SpawnMonster::clear_y() {
  _impl_.y_ = 0;
}
inline int32_t S_SpawnMonster::_internal_y() const {
  return _impl_.y_;
}
inline int32_t S_SpawnMonster::y() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SpawnMonster.y)
  return _internal_y();
}
inline void S_SpawnMonster::_internal_set_y(int32_t value) {
  
  _impl_.y_ = value;
}
inline void S_SpawnMonster::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Protocol.S_SpawnMonster.y)
}

// .Protocol.EDirection dir = 5;
inline void S_SpawnMonster::clear_dir() {
  _impl_.dir_ = 0;
}
inline ::Protocol::EDirection S_SpawnMonster::_internal_dir() const {
  return static_cast< ::Protocol::EDirection >(_impl_.dir_);
}
inline ::Protocol::EDirection S_SpawnMonster::dir() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SpawnMonster.dir)
  return _internal_dir();
}
inline void S_SpawnMonster::_internal_set_dir(::Protocol::EDirection value) {
  
  _impl_.dir_ = value;
}
inline void S_SpawnMonster::set_dir(::Protocol::EDirection value) {
  _internal_set_dir(value);
  // @@protoc_insertion_point(field_set:Protocol.S_SpawnMonster.dir)
}

// -------------------------------------------------------------------

// S_DespawnMonster

// int32 monsterId = 1;
inline void S_DespawnMonster::clear_monsterid() {
  _impl_.monsterid_ = 0;
}
inline int32_t S_DespawnMonster::_internal_monsterid() const {
  return _impl_.monsterid_;
}
inline int32_t S_DespawnMonster::monsterid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_DespawnMonster.monsterId)
  return _internal_monsterid();
}
inline void S_DespawnMonster::_internal_set_monsterid(int32_t value) {
  
  _impl_.monsterid_ = value;
}
inline void S_DespawnMonster::set_monsterid(int32_t value) {
  _internal_set_monsterid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_DespawnMonster.monsterId)
}

// .Protocol.EDespawnReason reason = 2;
inline void S_DespawnMonster::clear_reason() {
  _impl_.reason_ = 0;
}
inline ::Protocol::EDespawnReason S_DespawnMonster::_internal_reason() const {
  return static_cast< ::Protocol::EDespawnReason >(_impl_.reason_);
}
inline ::Protocol::EDespawnReason S_DespawnMonster::reason() const {
  // @@protoc_insertion_point(field_get:Protocol.S_DespawnMonster.reason)
  return _internal_reason();
}
inline void S_DespawnMonster::_internal_set_reason(::Protocol::EDespawnReason value) {
  
  _impl_.reason_ = value;
}
inline void S_DespawnMonster::set_reason(::Protocol::EDespawnReason value) {
  _internal_set_reason(value);
  // @@protoc_insertion_point(field_set:Protocol.S_DespawnMonster.reason)
}

// -------------------------------------------------------------------

// S_BroadcastMonsterMove

// int32 monsterId = 1;
inline void S_BroadcastMonsterMove::clear_monsterid() {
  _impl_.monsterid_ = 0;
}
inline int32_t S_BroadcastMonsterMove::_internal_monsterid() const {
  return _impl_.monsterid_;
}
inline int32_t S_BroadcastMonsterMove::monsterid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_BroadcastMonsterMove.monsterId)
  return _internal_monsterid();
}
inline void S_BroadcastMonsterMove::_internal_set_monsterid(int32_t value) {
  
  _impl_.monsterid_ = value;
}
inline void S_BroadcastMonsterMove::set_monsterid(int32_t value) {
  _internal_set_monsterid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_BroadcastMonsterMove.monsterId)
}

// int32 x = 2;
inline void S_BroadcastMonsterMove::clear_x() {
  _impl_.x_ = 0;
}
inline int32_t S_BroadcastMonsterMove::_internal_x() const {
  return _impl_.x_;
}
inline int32_t S_BroadcastMonsterMove::x() const {
  // @@protoc_insertion_point(field_get:Protocol.S_BroadcastMonsterMove.x)
  return _internal_x();
}
inline void S_BroadcastMonsterMove::_internal_set_x(int32_t value) {
  
  _impl_.x_ = value;
}
inline void S_BroadcastMonsterMove::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Protocol.S_BroadcastMonsterMove.x)
}

// int32 y = 3;
inline void S_BroadcastMonsterMove::clear_y() {
  _impl_.y_ = 0;
}
inline int32_t S_BroadcastMonsterMove::_internal_y() const {
  return _impl_.y_;
}
inline int32_t S_BroadcastMonsterMove::y() const {
  // @@protoc_insertion_point(field_get:Protocol.S_BroadcastMonsterMove.y)
  return _internal_y();
}
inline void S_BroadcastMonsterMove::_internal_set_y(int32_t value) {
  
  _impl_.y_ = value;
}
inline void S_BroadcastMonsterMove::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Protocol.S_BroadcastMonsterMove.y)
}

// .Protocol.EDirection dir = 4;
inline void S_BroadcastMonsterMove::clear_dir() {
  _impl_.dir_ = 0;
}
inline ::Protocol::EDirection S_BroadcastMonsterMove::_internal_dir() const {
  return static_cast< ::Protocol::EDirection >(_impl_.dir_);
}
inline ::Protocol::EDirection S_BroadcastMonsterMove::dir() const {
  // @@protoc_insertion_point(field_get:Protocol.S_BroadcastMonsterMove.dir)
  return _internal_dir();
}
inline void S_BroadcastMonsterMove::_internal_set_dir(::Protocol::EDirection value) {
  
  _impl_.dir_ = value;
}
inline void S_BroadcastMonsterMove::set_dir(::Protocol::EDirection value) {
  _internal_set_dir(value);
  // @@protoc_insertion_point(field_set:Protocol.S_BroadcastMonsterMove.dir)
}

// -------------------------------------------------------------------

// S_BroadcastMonsterAttack

// int32 monsterId = 1;
inline void S_BroadcastMonsterAttack::clear_monsterid() {
  _impl_.monsterid_ = 0;
}
inline int32_t S_BroadcastMonsterAttack::_internal_monsterid() const {
  return _impl_.monsterid_;
}
inline int32_t S_BroadcastMonsterAttack::monsterid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_BroadcastMonsterAttack.monsterId)
  return _internal_monsterid();
}
inline void S_BroadcastMonsterAttack::_internal_set_monsterid(int32_t value) {
  
  _impl_.monsterid_ = value;
}
inline void S_BroadcastMonsterAttack::set_monsterid(int32_t value) {
  _internal_set_monsterid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_BroadcastMonsterAttack.monsterId)
}

// int32 targetPid = 2;
inline void S_BroadcastMonsterAttack::clear_targetpid() {
  _impl_.targetpid_ = 0;
}
inline int32_t S_BroadcastMonsterAttack::_internal_targetpid() const {
  return _impl_.targetpid_;
}
inline int32_t S_BroadcastMonsterAttack::targetpid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_BroadcastMonsterAttack.targetPid)
  return _internal_targetpid();
}
inline void S_BroadcastMonsterAttack::_internal_set_targetpid(int32_t value) {
  
  _impl_.targetpid_ = value;
}
inline void S_BroadcastMonsterAttack::set_targetpid(int32_t value) {
  _internal_set_targetpid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_BroadcastMonsterAttack.targetPid)
}

// -------------------------------------------------------------------

// S_BroadcastMonsterDeath

// int32 monsterId = 1;
inline void S_BroadcastMonsterDeath::clear_monsterid() {
  _impl_.monsterid_ = 0;
}
inline int32_t S_BroadcastMonsterDeath::_internal_monsterid() const {
  return _impl_.monsterid_;
}
inline int32_t S_BroadcastMonsterDeath::monsterid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_BroadcastMonsterDeath.monsterId)
  return _internal_monsterid();
}
inline void S_BroadcastMonsterDeath::_internal_set_monsterid(int32_t value) {
  
  _impl_.monsterid_ = value;
}
inline void S_BroadcastMonsterDeath::set_monsterid(int32_t value) {
  _internal_set_monsterid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_BroadcastMonsterDeath.monsterId)
}

// -------------------------------------------------------------------

// Vector2Info

// int32 x = 1;
inline void Vector2Info::clear_x() {
  _impl_.x_ = 0;
}
inline int32_t Vector2Info::_internal_x() const {
  return _impl_.x_;
}
inline int32_t Vector2Info::x() const {
  // @@protoc_insertion_point(field_get:Protocol.Vector2Info.x)
  return _internal_x();
}
inline void Vector2Info::_internal_set_x(int32_t value) {
  
  _impl_.x_ = value;
}
inline void Vector2Info::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Protocol.Vector2Info.x)
}

// int32 y = 2;
inline void Vector2Info::clear_y() {
  _impl_.y_ = 0;
}
inline int32_t Vector2Info::_internal_y() const {
  return _impl_.y_;
}
inline int32_t Vector2Info::y() const {
  // @@protoc_insertion_point(field_get:Protocol.Vector2Info.y)
  return _internal_y();
}
inline void Vector2Info::_internal_set_y(int32_t value) {
  
  _impl_.y_ = value;
}
inline void Vector2Info::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Protocol.Vector2Info.y)
}

// -------------------------------------------------------------------

// PlayerMoveInfo

// int32 playerId = 1;
inline void PlayerMoveInfo::clear_playerid() {
  _impl_.playerid_ = 0;
}
inline int32_t PlayerMoveInfo::_internal_playerid() const {
  return _impl_.playerid_;
}
inline int32_t PlayerMoveInfo::playerid() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerMoveInfo.playerId)
  return _internal_playerid();
}
inline void PlayerMoveInfo::_internal_set_playerid(int32_t value) {
  
  _impl_.playerid_ = value;
}
inline void PlayerMoveInfo::set_playerid(int32_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:Protocol.PlayerMoveInfo.playerId)
}

// .Protocol.EDirection direction = 2;
inline void PlayerMoveInfo::clear_direction() {
  _impl_.direction_ = 0;
}
inline ::Protocol::EDirection PlayerMoveInfo::_internal_direction() const {
  return static_cast< ::Protocol::EDirection >(_impl_.direction_);
}
inline ::Protocol::EDirection PlayerMoveInfo::direction() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerMoveInfo.direction)
  return _internal_direction();
}
inline void PlayerMoveInfo::_internal_set_direction(::Protocol::EDirection value) {
  
  _impl_.direction_ = value;
}
inline void PlayerMoveInfo::set_direction(::Protocol::EDirection value) {
  _internal_set_direction(value);
  // @@protoc_insertion_point(field_set:Protocol.PlayerMoveInfo.direction)
}

// .Protocol.Vector2Info newPos = 3;
inline bool PlayerMoveInfo::_internal_has_newpos() const {
  return this != internal_default_instance() && _impl_.newpos_ != nullptr;
}
inline bool PlayerMoveInfo::has_newpos() const {
  return _internal_has_newpos();
}
inline void PlayerMoveInfo::clear_newpos() {
  if (GetArenaForAllocation() == nullptr && _impl_.newpos_ != nullptr) {
    delete _impl_.newpos_;
  }
  _impl_.newpos_ = nullptr;
}
inline const ::Protocol::Vector2Info& PlayerMoveInfo::_internal_newpos() const {
  const ::Protocol::Vector2Info* p = _impl_.newpos_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::Vector2Info&>(
      ::Protocol::_Vector2Info_default_instance_);
}
inline const ::Protocol::Vector2Info& PlayerMoveInfo::newpos() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerMoveInfo.newPos)
  return _internal_newpos();
}
inline void PlayerMoveInfo::unsafe_arena_set_allocated_newpos(
    ::Protocol::Vector2Info* newpos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.newpos_);
  }
  _impl_.newpos_ = newpos;
  if (newpos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.PlayerMoveInfo.newPos)
}
inline ::Protocol::Vector2Info* PlayerMoveInfo::release_newpos() {
  
  ::Protocol::Vector2Info* temp = _impl_.newpos_;
  _impl_.newpos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::Vector2Info* PlayerMoveInfo::unsafe_arena_release_newpos() {
  // @@protoc_insertion_point(field_release:Protocol.PlayerMoveInfo.newPos)
  
  ::Protocol::Vector2Info* temp = _impl_.newpos_;
  _impl_.newpos_ = nullptr;
  return temp;
}
inline ::Protocol::Vector2Info* PlayerMoveInfo::_internal_mutable_newpos() {
  
  if (_impl_.newpos_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::Vector2Info>(GetArenaForAllocation());
    _impl_.newpos_ = p;
  }
  return _impl_.newpos_;
}
inline ::Protocol::Vector2Info* PlayerMoveInfo::mutable_newpos() {
  ::Protocol::Vector2Info* _msg = _internal_mutable_newpos();
  // @@protoc_insertion_point(field_mutable:Protocol.PlayerMoveInfo.newPos)
  return _msg;
}
inline void PlayerMoveInfo::set_allocated_newpos(::Protocol::Vector2Info* newpos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.newpos_;
  }
  if (newpos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(newpos);
    if (message_arena != submessage_arena) {
      newpos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, newpos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.newpos_ = newpos;
  // @@protoc_insertion_point(field_set_allocated:Protocol.PlayerMoveInfo.newPos)
}

// -------------------------------------------------------------------

// CharacterSummaryInfo

// string username = 1;
inline void CharacterSummaryInfo::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& CharacterSummaryInfo::username() const {
  // @@protoc_insertion_point(field_get:Protocol.CharacterSummaryInfo.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CharacterSummaryInfo::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.CharacterSummaryInfo.username)
}
inline std::string* CharacterSummaryInfo::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:Protocol.CharacterSummaryInfo.username)
  return _s;
}
inline const std::string& CharacterSummaryInfo::_internal_username() const {
  return _impl_.username_.Get();
}
inline void CharacterSummaryInfo::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* CharacterSummaryInfo::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* CharacterSummaryInfo::release_username() {
  // @@protoc_insertion_point(field_release:Protocol.CharacterSummaryInfo.username)
  return _impl_.username_.Release();
}
inline void CharacterSummaryInfo::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.CharacterSummaryInfo.username)
}

// int32 level = 2;
inline void CharacterSummaryInfo::clear_level() {
  _impl_.level_ = 0;
}
inline int32_t CharacterSummaryInfo::_internal_level() const {
  return _impl_.level_;
}
inline int32_t CharacterSummaryInfo::level() const {
  // @@protoc_insertion_point(field_get:Protocol.CharacterSummaryInfo.level)
  return _internal_level();
}
inline void CharacterSummaryInfo::_internal_set_level(int32_t value) {
  
  _impl_.level_ = value;
}
inline void CharacterSummaryInfo::set_level(int32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:Protocol.CharacterSummaryInfo.level)
}

// .Protocol.EGender gender = 3;
inline void CharacterSummaryInfo::clear_gender() {
  _impl_.gender_ = 0;
}
inline ::Protocol::EGender CharacterSummaryInfo::_internal_gender() const {
  return static_cast< ::Protocol::EGender >(_impl_.gender_);
}
inline ::Protocol::EGender CharacterSummaryInfo::gender() const {
  // @@protoc_insertion_point(field_get:Protocol.CharacterSummaryInfo.gender)
  return _internal_gender();
}
inline void CharacterSummaryInfo::_internal_set_gender(::Protocol::EGender value) {
  
  _impl_.gender_ = value;
}
inline void CharacterSummaryInfo::set_gender(::Protocol::EGender value) {
  _internal_set_gender(value);
  // @@protoc_insertion_point(field_set:Protocol.CharacterSummaryInfo.gender)
}

// .Protocol.ERegion region = 4;
inline void CharacterSummaryInfo::clear_region() {
  _impl_.region_ = 0;
}
inline ::Protocol::ERegion CharacterSummaryInfo::_internal_region() const {
  return static_cast< ::Protocol::ERegion >(_impl_.region_);
}
inline ::Protocol::ERegion CharacterSummaryInfo::region() const {
  // @@protoc_insertion_point(field_get:Protocol.CharacterSummaryInfo.region)
  return _internal_region();
}
inline void CharacterSummaryInfo::_internal_set_region(::Protocol::ERegion value) {
  
  _impl_.region_ = value;
}
inline void CharacterSummaryInfo::set_region(::Protocol::ERegion value) {
  _internal_set_region(value);
  // @@protoc_insertion_point(field_set:Protocol.CharacterSummaryInfo.region)
}

// -------------------------------------------------------------------

// PlayerInfo

// int32 id = 1;
inline void PlayerInfo::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t PlayerInfo::_internal_id() const {
  return _impl_.id_;
}
inline int32_t PlayerInfo::id() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerInfo.id)
  return _internal_id();
}
inline void PlayerInfo::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void PlayerInfo::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Protocol.PlayerInfo.id)
}

// string username = 2;
inline void PlayerInfo::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& PlayerInfo::username() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerInfo.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerInfo::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.PlayerInfo.username)
}
inline std::string* PlayerInfo::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:Protocol.PlayerInfo.username)
  return _s;
}
inline const std::string& PlayerInfo::_internal_username() const {
  return _impl_.username_.Get();
}
inline void PlayerInfo::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* PlayerInfo::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* PlayerInfo::release_username() {
  // @@protoc_insertion_point(field_release:Protocol.PlayerInfo.username)
  return _impl_.username_.Release();
}
inline void PlayerInfo::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.PlayerInfo.username)
}

// .Protocol.Vector2Info pos = 3;
inline bool PlayerInfo::_internal_has_pos() const {
  return this != internal_default_instance() && _impl_.pos_ != nullptr;
}
inline bool PlayerInfo::has_pos() const {
  return _internal_has_pos();
}
inline void PlayerInfo::clear_pos() {
  if (GetArenaForAllocation() == nullptr && _impl_.pos_ != nullptr) {
    delete _impl_.pos_;
  }
  _impl_.pos_ = nullptr;
}
inline const ::Protocol::Vector2Info& PlayerInfo::_internal_pos() const {
  const ::Protocol::Vector2Info* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::Vector2Info&>(
      ::Protocol::_Vector2Info_default_instance_);
}
inline const ::Protocol::Vector2Info& PlayerInfo::pos() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerInfo.pos)
  return _internal_pos();
}
inline void PlayerInfo::unsafe_arena_set_allocated_pos(
    ::Protocol::Vector2Info* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.PlayerInfo.pos)
}
inline ::Protocol::Vector2Info* PlayerInfo::release_pos() {
  
  ::Protocol::Vector2Info* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::Vector2Info* PlayerInfo::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:Protocol.PlayerInfo.pos)
  
  ::Protocol::Vector2Info* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::Protocol::Vector2Info* PlayerInfo::_internal_mutable_pos() {
  
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::Vector2Info>(GetArenaForAllocation());
    _impl_.pos_ = p;
  }
  return _impl_.pos_;
}
inline ::Protocol::Vector2Info* PlayerInfo::mutable_pos() {
  ::Protocol::Vector2Info* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:Protocol.PlayerInfo.pos)
  return _msg;
}
inline void PlayerInfo::set_allocated_pos(::Protocol::Vector2Info* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:Protocol.PlayerInfo.pos)
}

// .Protocol.EDirection direction = 4;
inline void PlayerInfo::clear_direction() {
  _impl_.direction_ = 0;
}
inline ::Protocol::EDirection PlayerInfo::_internal_direction() const {
  return static_cast< ::Protocol::EDirection >(_impl_.direction_);
}
inline ::Protocol::EDirection PlayerInfo::direction() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerInfo.direction)
  return _internal_direction();
}
inline void PlayerInfo::_internal_set_direction(::Protocol::EDirection value) {
  
  _impl_.direction_ = value;
}
inline void PlayerInfo::set_direction(::Protocol::EDirection value) {
  _internal_set_direction(value);
  // @@protoc_insertion_point(field_set:Protocol.PlayerInfo.direction)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::Protocol::MsgId> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::MsgId>() {
  return ::Protocol::MsgId_descriptor();
}
template <> struct is_proto_enum< ::Protocol::ELoginResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::ELoginResult>() {
  return ::Protocol::ELoginResult_descriptor();
}
template <> struct is_proto_enum< ::Protocol::EGender> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::EGender>() {
  return ::Protocol::EGender_descriptor();
}
template <> struct is_proto_enum< ::Protocol::ERegion> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::ERegion>() {
  return ::Protocol::ERegion_descriptor();
}
template <> struct is_proto_enum< ::Protocol::EDirection> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::EDirection>() {
  return ::Protocol::EDirection_descriptor();
}
template <> struct is_proto_enum< ::Protocol::ELeaveReason> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::ELeaveReason>() {
  return ::Protocol::ELeaveReason_descriptor();
}
template <> struct is_proto_enum< ::Protocol::EMoveResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::EMoveResult>() {
  return ::Protocol::EMoveResult_descriptor();
}
template <> struct is_proto_enum< ::Protocol::EEnterReason> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::EEnterReason>() {
  return ::Protocol::EEnterReason_descriptor();
}
template <> struct is_proto_enum< ::Protocol::EDespawnReason> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::EDespawnReason>() {
  return ::Protocol::EDespawnReason_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto
